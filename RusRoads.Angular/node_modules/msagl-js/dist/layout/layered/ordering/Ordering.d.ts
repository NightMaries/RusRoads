import { LayerArrays } from '../LayerArrays';
import { ProperLayeredGraph } from '../ProperLayeredGraph';
import { SugiyamaLayoutSettings } from '../SugiyamaLayoutSettings';
import { OrderingMeasure } from './OrderingMeasure';
import { CancelToken } from '../../../utils/cancelToken';
import { Algorithm } from './../../../utils/algorithm';
export declare function GetCrossingsTotal(properLayeredGraph: ProperLayeredGraph, layerArrays: LayerArrays): number;
export declare class Ordering extends Algorithm {
    hasCrossWeights: boolean;
    layerArrays: LayerArrays;
    layerArraysCopy: number[][];
    layering: number[];
    layers: number[][];
    measure: OrderingMeasure;
    nOfLayers: number;
    properLayeredGraph: ProperLayeredGraph;
    SugSettings: SugiyamaLayoutSettings;
    startOfVirtNodes: number;
    tryReverse: boolean;
    get NoGainStepsBound(): number;
    get SeedOfRandom(): number;
    X: number[];
    constructor(graphPar: ProperLayeredGraph, tryReverse: boolean, layerArraysParam: LayerArrays, startOfVirtualNodes: number, hasCrossWeights: boolean, settings: SugiyamaLayoutSettings, cancelToken: CancelToken);
    get MaxOfIterations(): number;
    static OrderLayers(graph: ProperLayeredGraph, layerArrays: LayerArrays, startOfVirtualNodes: number, settings: SugiyamaLayoutSettings, cancelToken: CancelToken): void;
    run(): void;
    Calculate(): void;
    static CloneLayers(layers: number[][], layerArraysCopy: number[][]): number[][];
    Restore(): void;
    LayerByLayerSweep(up: boolean): void;
    SweepLayer(layer: number, upperLayer: boolean): void;
    Sort(layerToSort: number, medianValues: number[]): void;
    WMedian(node: number, theMedianGoingDown: boolean): number;
    Init(): void;
    predecessors: number[][];
    pOrder: Map<number, number>[];
    successors: number[][];
    sOrder: Map<number, number>[];
    inCrossingCount: Map<number, number>[];
    MaxNumberOfAdjacentExchanges: number;
    outCrossingCount: Map<number, number>[];
    AdjacentExchange(): void;
    AllocArrays(): void;
    InitArrays(): void;
    CalcPair(u: number, v: number): {
        cuv: number;
        cvu: number;
    };
    InitPsArraysForLayer(layer: number[]): void;
    CountOnArrays(unbs: number[], vnbs: number[]): number;
    CountOnArraysUV(unbs: number[], vnbs: number[], uCrossingCounts: Map<number, number>, vCrossingCount: Map<number, number>): number;
    AdjExchangeLayer(i: number): boolean;
    Swap(u: number, v: number): void;
    UpdatePsContainingUv(u: number, v: number): void;
    UpdateSsContainingUv(u: number, v: number): void;
    DisturbLayer(layer: number[]): void;
    ExchangeWithGainWithNoDisturbance(layer: number[]): boolean;
    ExchangeWithGain(layer: number[]): boolean;
    SwapToTheLeft(layer: number[], i: number): void;
    SwapToTheRight(layer: number[], i: number): void;
    AdjacentSwapToTheRight(layer: number[], i: number): void;
    SwapGain(u: number, v: number): number;
    UvAreOfSameKind(u: number, v: number): boolean;
    NeighborsForbidTheSwap(u: number, v: number): boolean;
    LowerNeighborsForbidTheSwap(u: number, v: number): boolean;
    UpperNeighborsForbidTheSwap(u: number, v: number): boolean;
    CalcDeltaBetweenGroupsToTheLeftAndToTheRightOfTheSeparator(layer: number[], separatorPosition: number, separator: number): number;
    IsOriginal(v: number): boolean;
    IsVirtual(v: number): boolean;
    GetKindDelegate(v: number): (v: number) => boolean;
    SwapWithGain(u: number, v: number): boolean;
}
