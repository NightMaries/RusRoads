export class OrderingMeasure {
    constructor(layerArraysPar, numOfCrossings, virtualVertexStart) {
        this.numberOfCrossings = numOfCrossings;
        this.la = layerArraysPar;
        this.virtVertexStart = virtualVertexStart;
    }
    LayerGroupDisbalance(l, origGroupOptSize, virtGroupOptSize) {
        if (origGroupOptSize == 1)
            return this.LayerGroupDisbalanceWithOrigSeparators(l, virtGroupOptSize);
        else
            return this.LayerGroupDisbalanceWithVirtSeparators(l, origGroupOptSize);
    }
    LayerGroupDisbalanceWithVirtSeparators(l, origGroupOptSize) {
        let ret = 0;
        for (let i = 0; i < l.length;) {
            const r = this.CurrentOrigGroupDelta(i, l, origGroupOptSize);
            i = r.i;
            ret += r.ret;
        }
        return ret;
    }
    CurrentOrigGroupDelta(i, l, origGroupOptSize) {
        let groupSize = 0;
        let j = i;
        for (; j < l.length && l[j] < this.virtVertexStart; j++)
            groupSize++;
        i = j + 1;
        return { ret: Math.abs(origGroupOptSize - groupSize), i };
    }
    LayerGroupDisbalanceWithOrigSeparators(l, virtGroupOptSize) {
        let ret = 0;
        for (let i = 0; i < l.length;) {
            const r = this.CurrentVirtGroupDelta(i, l, virtGroupOptSize);
            ret += r.ret;
            i = r.i;
        }
        return ret;
    }
    CurrentVirtGroupDelta(i, l, virtGroupOptSize) {
        let groupSize = 0;
        let j = i;
        for (; j < l.length && l[j] >= this.virtVertexStart; j++)
            groupSize++;
        i = j + 1;
        return { ret: Math.abs(virtGroupOptSize - groupSize), i: i };
    }
    static less(a, b) {
        return a.numberOfCrossings < b.numberOfCrossings;
    }
    static greater(a, b) {
        return a.numberOfCrossings > b.numberOfCrossings;
    }
    IsPerfect() {
        return this.numberOfCrossings == 0;
    }
}
//# sourceMappingURL=OrderingMeasure.js.map