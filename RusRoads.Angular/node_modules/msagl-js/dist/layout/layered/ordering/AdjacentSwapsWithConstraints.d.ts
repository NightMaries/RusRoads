import { LayerArrays } from '../LayerArrays';
import { ProperLayeredGraph } from '../ProperLayeredGraph';
import { LayerInfo } from './LayerInfo';
export declare class AdjacentSwapsWithConstraints {
    static maxNumberOfAdjacentExchanges: number;
    hasCrossWeights: boolean;
    layerInfos: LayerInfo[];
    layering: number[];
    layers: number[][];
    properLayeredGraph: ProperLayeredGraph;
    X: number[];
    inCrossingCount: Map<number, number>[];
    outCrossingCount: Map<number, number>[];
    P: number[][];
    POrder: Map<number, number>[];
    S: number[][];
    SOrder: Map<number, number>[];
    constructor(layerArray: LayerArrays, hasCrossWeights: boolean, properLayeredGraph: ProperLayeredGraph, layerInfos: LayerInfo[]);
    static get MaxNumberOfAdjacentExchanges(): number;
    ExchangeWithGainWithNoDisturbance(layer: number[]): boolean;
    CanSwap(i: number, j: number): boolean;
    IsVirtualNode(v: number): boolean;
    SwapWithGain(u: number, v: number): boolean;
    SwapGain(u: number, v: number): number;
    CalcPair(u: number, v: number, t: {
        cuv: number;
        cvu: number;
    }): void;
    CountOnArrays(unbs: Array<number>, vnbs: Array<number>): number;
    CountOnArrays_(unbs: Array<number>, vnbs: Array<number>, uCrossingCounts: Map<number, number>, vCrossingCount: Map<number, number>): number;
    Swap(u: number, v: number): void;
    ExchangeWithGain(layer: number[]): boolean;
    HeadOfTheCoin(): boolean;
    DoSwaps(): void;
    private SPAreCorrect;
    private SIsCorrect;
    InitArrays(): void;
    DisturbLayer(layer: number[]): void;
    AdjExchangeLayer(i: number): boolean;
    AllocArrays(): void;
    UpdatePsContainingUV(u: number, v: number): void;
    SwapToTheRight(layer: number[], i: number): void;
    SwapToTheLeft(layer: number[], i: number): void;
    AdjacentSwapToTheRight(layer: number[], i: number): void;
    InitPSArraysForLayer(layer: number[]): void;
    UpdateSsContainingUV(u: number, v: number): void;
    private UAndVAreOnSameLayer;
    private UIsToTheLeftOfV;
}
