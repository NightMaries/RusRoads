import { GetCrossingsTotal } from './Ordering';
export class ConstrainedOrdering {
    constructor(geomGraph, basicIntGraph, layering, nodeIdToIndex, database, settings) {
        this.verticalEdges = new Array();
        this.numberOfLayers = -1;
        this.layersAreDoubled = false;
        throw new Error('not implemented');
        // this.settings = this.settings;
        // this.horizontalConstraints = this.settings.HorizontalConstraints;
        // this.horizontalConstraints.PrepareForOrdering(nodeIdToIndex, layering);
        // this.geometryGraph = geomGraph;
        // this.database = this.database;
        // this.intGraph = basicIntGraph;
        // this.initialLayering = layering;
        // // this has to be changed only to insert layers that are needed
        // if (this.NeedToInsertLayers(layering)) {
        //   for (let i= 0; (i < layering.length); i++) {
        //     layering[i] = (layering[i] * 2);
        //   }
        //   this.LayersAreDoubled = true;
        //   this.numberOfLayers = -1;
        // }
        // this.PrepareProperLayeredGraphAndFillLayerInfos();
        // this.adjSwapper = new AdjacentSwapsWithConstraints(this.LayerArrays, this.HasCrossWeights(), this.ProperLayeredGraph, this.layerInfos);
    }
    get NumberOfLayers() {
        throw new Error('not implemented');
        if (this.numberOfLayers > 0) {
            return this.numberOfLayers;
        }
        return 0;
    }
    NodeSeparation() {
        return this.settings.NodeSeparation;
    }
    get LayersAreDoubled() {
        return this.layersAreDoubled;
    }
    set LayersAreDoubled(value) {
        this.layersAreDoubled = value;
    }
    NeedToInsertLayers(layering) {
        return (ConstrainedOrdering.ExistsShortLabeledEdge(layering, Array.from(this.intGraph.edges)) ||
            ConstrainedOrdering.ExistsShortMultiEdge(layering, this.database.Multiedges));
    }
    static ExistsShortMultiEdge(layering, multiedges) {
        return Array.from(multiedges.keyValues()).some(([k, v]) => v.length > 2 && layering[k.x] == 1 + layering[k.y]);
    }
    //  Calculate() {
    //   this.AllocateXPositions();
    //   let originalGraph = (<GeomGraph>(this.intGraph.Nodes[0].GeometryParent));
    //   LayeredLayoutEngine.CalculateAnchorSizes(this.database, TODOOUTthis.database.anchors, this.ProperLayeredGraph, originalGraph, this.intGraph, this.settings);
    //   LayeredLayoutEngine.CalcInitialYAnchorLocations(this.LayerArrays, 500, this.geometryGraph, this.database, this.intGraph, this.settings, this.LayersAreDoubled);
    //   this.Order();
    // }
    CreateMeasure() {
        return GetCrossingsTotal(this.ProperLayeredGraph, this.LayerArrays);
    }
    HasCrossWeights() {
        for (const le of this.ProperLayeredGraph.Edges) {
            if (le.CrossingWeight != 1)
                return true;
        }
        return false;
    }
    static ExistsShortLabeledEdge(layering, edges) {
        return edges.some((edge) => layering[edge.source] == layering[edge.target] + 1 && edge.edge.label != null);
    }
    AllocateXPositions() {
        this.xPositions = new Array(this.NumberOfLayers);
        for (let i = 0; i < this.NumberOfLayers; i++) {
            this.xPositions[i] = new Array(this.LayerArrays.Layers[i].length);
        }
    }
    Order() {
        throw new Error('not implemented');
        // this.CreateInitialOrderInLayers();
        // this.TryPushingOutStrangersFromHorizontalBlocks();
        // let n= 5;
        // let measure = Number.MAX_SAFE_INTEGER;
        // while (n-- > 0 && this.noGainSteps <= ConstrainedOrdering.MaxNumberOfNoGainSteps) {
        //   this.SetXPositions();
        //   let newMeasure = this.CreateMeasure();
        //   if (newMeasure < measure) {
        //     this.noGainSteps = 0;
        //     const t = { layerArraysCopy: this.yetBestLayers }
        //     Ordering.CloneLayers(this.LayerArrays.Layers, t);
        //     this.yetBestLayers = t.layerArraysCopy
        //     measure = newMeasure;
        //   }
        //   else {
        //     this.noGainSteps++;
        //     this.RestoreState();
        //   }
        // }
    }
    SetXPositions() {
        throw new Error('not implemented');
    }
    // InitSolverWithoutOrder(): ISolverShell {
    //   let solver: ISolverShell = ConstrainedOrdering.CreateSolver();
    //   this.InitSolverVars(solver);
    //   this.PutLeftRightConstraintsIntoSolver(solver);
    //   this.PutVerticalConstraintsIntoSolver(solver);
    //   this.AddGoalsToKeepProperEdgesShort(solver);
    //   this.AddGoalsToKeepFlatEdgesShort(solver);
    //   return solver;
    // }
    // SortLayers(solver: ISolverShell) {
    //   for (let i= 0; (i < this.LayerArrays.Layers.length); i++) {
    //     this.SortLayerBasedOnSolution(this.LayerArrays.Layers[i], solver);
    //   }
    // }
    // AddGoalsToKeepFlatEdgesShort(solver: ISolverShell) {
    //   for (let layerInfo of this.layerInfos) {
    //     ConstrainedOrdering.AddGoalToKeepFlatEdgesShortOnBlockLevel(layerInfo, solver);
    //   }
    // }
    // InitSolverVars(solver: ISolverShell) {
    //   for (let i= 0; (i < this.LayerArrays.y.length); i++) {
    //     solver.AddVariableWithIdealPosition(i, 0);
    //   }
    // }
    // AddGoalsToKeepProperEdgesShort(solver: ISolverShell) {
    //   for (let edge of this.ProperLayeredGraph.edges) {
    //     solver.AddGoalTwoVariablesAreClose(edge.Source, edge.Target, PositionOverBaricenterWeight);
    //   }
    // }
    // PutVerticalConstraintsIntoSolver(solver: ISolverShell) {
    //   for (let pair of this.horizontalConstraints.VerticalInts) {
    //     solver.AddGoalTwoVariablesAreClose(pair.Item1, pair.Item2, ConstrainedVarWeight);
    //   }
    // }
    // PutLeftRightConstraintsIntoSolver(solver: ISolverShell) {
    //   for (let pair of this.horizontalConstraints.LeftRighInts) {
    //     solver.AddLeftRightSeparationConstraint(pair.Item1, pair.Item2, this.SimpleGapBetweenTwoNodes(pair.Item1, pair.Item2));
    //   }
    // }
    // PutLayerNodeSeparationsIntoSolver(solver: ISolverShell) {
    //   for (let layer of this.LayerArrays.Layers) {
    //     for (let i= 0; (i
    //       < (layer.length - 1)); i++) {
    //       let l: number = layer[i];
    //       let r: number = layer[(i + 1)];
    //       solver.AddLeftRightSeparationConstraint(l, r, this.SimpleGapBetweenTwoNodes(l, r));
    //     }
    //   }
    // }
    // ImproveWithAdjacentSwaps() {
    //   this.adjSwapper.DoSwaps();
    // }
    // TryPushingOutStrangersFromHorizontalBlocks() {
    // }
    // CreateInitialOrderInLayers() {
    //   // the idea is to topologically ordering all nodes horizontally, by using vertical components, then fill the layers according to this order
    //   let nodesToVerticalComponentsRoots: Map<number, number> = this.CreateVerticalComponents();
    //   let liftedLeftRightRelations: Array<IntPair> = this.LiftLeftRightRelationsToComponentRoots(nodesToVerticalComponentsRoots).ToArray();
    //   let orderOfVerticalComponentRoots: number[] = TopologicalSort.GetOrderOnEdges(liftedLeftRightRelations);
    //   this.FillLayersWithVerticalComponentsOrder(orderOfVerticalComponentRoots, nodesToVerticalComponentsRoots);
    //   this.LayerArrays.UpdateXFromLayers();
    // }
    // FillLayersWithVerticalComponentsOrder(order: number[], nodesToVerticalComponentsRoots: Map<number, number>) {
    //   let componentRootsToComponents: Map<number, Array<number>> = ConstrainedOrdering.CreateComponentRootsToComponentsMap(nodesToVerticalComponentsRoots);
    //   let alreadyInLayers = new Array(this.LayerArrays.y.length);
    //   let runninglayerCounts = new Array(this.LayerArrays.Layers.length);
    //   for (let vertCompRoot of order) {
    //     this.PutVerticalComponentIntoLayers(this.EnumerateVertComponent(componentRootsToComponents, vertCompRoot), runninglayerCounts, alreadyInLayers);
    //   }
    //   for (let i= 0; (i < this.ProperLayeredGraph.NodeCount); i++) {
    //     if ((alreadyInLayers[i] == false)) {
    //       this.AddVertToLayers(i, runninglayerCounts, alreadyInLayers);
    //     }
    //   }
    // }
    // EnumerateVertComponent(componentRootsToComponents: Map<number, Array<number>>, vertCompRoot: number): Array<number> {
    //   let compList: Array<number>;
    //   if (componentRootsToComponents.TryGetValue(vertCompRoot, TODOOUTcompList)) {
    //     for (let i of compList) {
    //       yield;
    //     }
    //     return i;
    //   }
    //   else {
    //     yield;
    //   }
    //   return vertCompRoot;
    // }
    // PutVerticalComponentIntoLayers(vertComponent: Array<number>, runningLayerCounts: number[], alreadyInLayers: boolean[]) {
    //   for (let i of vertComponent) {
    //     this.AddVertToLayers(i, runningLayerCounts, alreadyInLayers);
    //   }
    // }
    // AddVertToLayers(i: number, runningLayerCounts: number[], alreadyInLayers: boolean[]) {
    //   if (alreadyInLayers[i]) {
    //     return;
    //   }
    //   let layerIndex: number = this.LayerArrays.y[i];
    //   let xIndex: number = runningLayerCounts[layerIndex];
    //   let layer = this.LayerArrays.Layers[layerIndex];
    //   layer[xIndex++] = i;
    //   alreadyInLayers[i] = true;
    //   let block: Array<number>;
    //   if (this.horizontalConstraints.BlockRootToBlock.TryGetValue(i, TODOOUTblock)) {
    //     for (let v of block) {
    //       if (alreadyInLayers[v]) {
    //         continue
    //       }
    //       layer[xIndex++] = v;
    //       alreadyInLayers[v] = true;
    //     }
    //   }
    //   runningLayerCounts[layerIndex] = xIndex;
    // }
    // static CreateComponentRootsToComponentsMap(nodesToVerticalComponentsRoots: Map<number, number>): Map<number, Array<number>> {
    //   let d = new Map<number, Array<number>>();
    //   for (let kv of nodesToVerticalComponentsRoots) {
    //     let i: number = kv.Key;
    //     let root = kv.Value;
    //     let component: Array<number>;
    //     if (!d.TryGetValue(root, TODOOUTcomponent)) {
    //       component = new Array<number>();
    //       d[root] = new Array<number>();
    //     }
    //     component.Add(i);
    //   }
    //   return d;
    // }
    // LiftLeftRightRelationsToComponentRoots(nodesToVerticalComponentsRoots: Map<number, number>): Array<IntPair> {
    //   for (let pair of this.horizontalConstraints.LeftRighInts) {
    //     yield;
    //   }
    //   return new IntPair(ConstrainedOrdering.GetFromDictionaryOrIdentical(nodesToVerticalComponentsRoots, pair.Item1), ConstrainedOrdering.GetFromDictionaryOrIdentical(nodesToVerticalComponentsRoots, pair.Item2));
    //   for (let pair of this.horizontalConstraints.LeftRightIntNeibs) {
    //     yield;
    //   }
    //   return new IntPair(ConstrainedOrdering.GetFromDictionaryOrIdentical(nodesToVerticalComponentsRoots, pair.Item1), ConstrainedOrdering.GetFromDictionaryOrIdentical(nodesToVerticalComponentsRoots, pair.Item2));
    // }
    // static GetFromDictionaryOrIdentical(d: Map<number, number>, key: number): number {
    //   let i: number;
    //   if (d.TryGetValue(key, TODOOUTi)) {
    //     return i;
    //   }
    //   return key;
    // }
    // //  These blocks are connected components in the vertical constraints. They don't necesserely span consequent layers.
    //
    // CreateVerticalComponents(): Map<number, number> {
    //   let vertGraph = new BasicGraphOnEdges<PolyIntEdge>(from, pair, in, this.horizontalConstraints.VerticalInts, select, new PolyIntEdge(pair.Item1, pair.Item2));
    //   let verticalComponents = ConnectedComponentCalculator.GetComponents(vertGraph);
    //   let nodesToComponentRoots = new Map<number, number>();
    //   for (let component of verticalComponents) {
    //     let ca = component.ToArray();
    //     if ((ca.length == 1)) {
    //       continue
    //     }
    //     let componentRoot: number = -1;
    //     for (let j of component) {
    //       if ((componentRoot == -1)) {
    //         componentRoot = j;
    //       }
    //       nodesToComponentRoots[j] = componentRoot;
    //     }
    //   }
    //   return nodesToComponentRoots;
    // }
    // RestoreState() {
    //   this.LayerArrays.UpdateLayers(this.yetBestLayers);
    // }
    // @System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledCode")
    // Show() {
    //   SugiyamaLayoutSettings.ShowDatabase(this.database);
    // }
    // @System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1303:Do not pass literals as localized parameters", MessageId = "System.Diagnostics.Debug.Write(System.String)")
    // @System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledCode")
    // static PrintPositions(positions: number[]) {
    //   for (let j= 0; (j < positions.length); j++) {
    //     System.Diagnostics.Debug.Write((" " + positions[j]));
    //   }
    //   System.Diagnostics.Debug.WriteLine("");
    // }
    // SortLayerBasedOnSolution(layer: number[], solver: ISolverShell) {
    //   let length: number = layer.length;
    //   let positions = new Array(length);
    //   let k= 0;
    //   for (let v: number of layer) {
    //     positions[k++] = solver.GetVariableResolvedPosition(v);
    //   }
    //   Array.Sort(positions, layer);
    //   let i= 0;
    //   for (let v: number of layer) {
    //     i++;
    //   }
    //   this.LayerArrays.x[v] = i;
    // }
    //       /* const */ static ConstrainedVarWeight= 10000000;
    //       /* const */ static PositionOverBaricenterWeight= 5;
    // static NodeToBlockRootSoftOnLayerInfo(layerInfo: LayerInfo, node: number): number {
    //   let root: number;
    //   return layerInfo.nodeToBlockRoot.TryGetValue(node, TODOOUTroot);
    //   // TODO: Warning!!!, inline IF is not supported ?
    //   // TODO: Warning!!!! NULL EXPRESSION DETECTED...
    //   ;
    // }
    // static AddGoalToKeepFlatEdgesShortOnBlockLevel(layerInfo: LayerInfo, solver: ISolverShell) {
    //   if ((layerInfo != null)) {
    //     for (let couple of layerInfo.flatEdges) {
    //       let sourceBlockRoot: number = ConstrainedOrdering.NodeToBlockRootSoftOnLayerInfo(layerInfo, couple.Item1);
    //       let targetBlockRoot: number = ConstrainedOrdering.NodeToBlockRootSoftOnLayerInfo(layerInfo, couple.Item2);
    //       if ((sourceBlockRoot != targetBlockRoot)) {
    //         solver.AddGoalTwoVariablesAreClose(sourceBlockRoot, targetBlockRoot);
    //       }
    //     }
    //   }
    // }
    // static NodeIsConstrainedBelow(v: number, layerInfo: LayerInfo): boolean {
    //   if ((layerInfo == null)) {
    //     return false;
    //   }
    //   return layerInfo.constrainedFromBelow.ContainsKey(v);
    // }
    // static NodeIsConstrainedAbove(v: number, layerInfo: LayerInfo): boolean {
    //   if ((layerInfo == null)) {
    //     return false;
    //   }
    //   return layerInfo.constrainedFromAbove.ContainsKey(v);
    // }
    static BelongsToNeighbBlock(p, layerInfo) {
        return layerInfo != null && (layerInfo.nodeToBlockRoot.has(p) || layerInfo.neigBlocks.has(p));
        // p is a root of the block
    }
}
ConstrainedOrdering.MaxNumberOfNoGainSteps = 5;
//# sourceMappingURL=ConstrainedOrdering.js.map