import { Point } from '../../math/geometry/point';
import { FloatingPort } from './floatingPort';
export class RelativeFloatingPort extends FloatingPort {
    //  Create a port relative to a specific node with an offset for the port Location from the nodes center
    constructor(curveDelegate, centerDelegate, locationOffset) {
        super(null, centerDelegate().add(locationOffset));
        this.LocationOffset = locationOffset;
        this.CurveDelegate = curveDelegate;
        this.CenterDelegate = centerDelegate;
    }
    static mk(boundaryDelegate, centerDelegate) {
        return new RelativeFloatingPort(boundaryDelegate, centerDelegate, new Point(0, 0));
    }
    //  the delegate returning center
    get CenterDelegate() {
        return this.centerDelegate;
    }
    set CenterDelegate(value) {
        this.centerDelegate = value;
    }
    //  the delegate returning center
    get CurveDelegate() {
        return this.curveDelegate;
    }
    set CurveDelegate(value) {
        this.curveDelegate = value;
    }
    //
    //         // The node where we calculate our location and Curve from
    //
    //         public Node RelativeTo { get; private set; }
    //  An offset relative to the Center of the Node that we use to calculate Location
    get LocationOffset() {
        return this.locationOffset;
    }
    set LocationOffset(value) {
        this.locationOffset = value;
    }
    //
    // //  Create a port relative to the center of a specific node
    //
    // public constructor (curveDelegate: Func<ICurve>, centerDelegate: Func<Point>) :
    //         this(curveDelegate, centerDelegate, new Point()) {
    // }
    //  Get the location = CenterDelegate() + LocationOffset
    get Location() {
        return this.CenterDelegate().add(this.LocationOffset);
    }
    //  Get the curve from the node's BoundaryCurve
    get Curve() {
        return this.CurveDelegate();
    }
}
//# sourceMappingURL=relativeFloatingPort.js.map