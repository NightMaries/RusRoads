// A node of a GeomGraph
import { CurveFactory } from './../../math/geometry/curveFactory';
import { GeomObject } from './geomObject';
export class GeomNode extends GeomObject {
    constructor() {
        super(...arguments);
        this.padding = 1;
    }
    get isGraph() {
        return false;
    }
    get node() {
        return this.attrCont;
    }
    get boundaryCurve() {
        return this._boundaryCurve;
    }
    set boundaryCurve(value) {
        if ((value != null && value.boundingBox.height < GeomNode.minHeight) || value.boundingBox.width < GeomNode.minWidth) {
            value = CurveFactory.mkCircle(GeomNode.minWidth, value.boundingBox.center);
        }
        this._boundaryCurve = value;
    }
    get id() {
        return this.node.id;
    }
    toString() {
        return this.id;
    }
    // Creates a Node instance
    static mkNode(curve, node) {
        const n = new GeomNode(node);
        n.boundaryCurve = curve;
        return n;
    }
    // Fields which are set by Msagl
    // return the center of the curve bounding box
    get center() {
        return this.boundaryCurve.boundingBox.center;
    }
    set center(value) {
        const del = value.sub(this.center);
        this.boundaryCurve.translate(del);
    }
    // sets the bounding curve scaled to fit the targetBounds
    fitBoundaryCurveToTarget(targetBounds) {
        if (this.boundaryCurve != null) {
            // RoundedRect is special, rather then simply scaling the geometry we want to keep the corner radii constant
            const radii = CurveFactory.isRoundedRect(this.boundaryCurve);
            if (radii == undefined) {
                /*Assert.assert(this.boundaryCurve.boundingBox.width > 0)*/
                /*Assert.assert(this.boundaryCurve.boundingBox.height > 0)*/
                const scaleX = targetBounds.width / this.boundaryCurve.boundingBox.width;
                const scaleY = targetBounds.height / this.boundaryCurve.boundingBox.height;
                this.boundaryCurve = this.boundaryCurve.scaleFromOrigin(scaleX, scaleY);
                this.boundaryCurve.translate(targetBounds.center.sub(this.boundaryCurve.boundingBox.center));
            }
            else {
                this.boundaryCurve = CurveFactory.mkRectangleWithRoundedCorners(targetBounds.width, targetBounds.height, radii.radX, radii.radY, targetBounds.center);
            }
        }
    }
    *inEdges() {
        for (const e of this.node.inEdges) {
            yield GeomObject.getGeom(e);
        }
    }
    *outEdges() {
        for (const e of this.node.outEdges) {
            yield GeomObject.getGeom(e);
        }
    }
    *selfEdges() {
        for (const e of this.node.selfEdges) {
            yield GeomObject.getGeom(e);
        }
    }
    // the bounding box of the node
    get boundingBox() {
        return this.boundaryCurve ? this.boundaryCurve.boundingBox : null;
    }
    set boundingBox(value) {
        if (!this.boundaryCurve) {
            return;
        }
        if (Math.abs(value.width - this.width) < 0.0001 && Math.abs(value.height - this.height) < 0.0001) {
            this.center = value.center;
        }
        else {
            this.fitBoundaryCurveToTarget(value);
        }
    }
    // width of the node does not include the padding
    get width() {
        return this.boundaryCurve.boundingBox.width;
    }
    // height of the node does not including the padding
    get height() {
        return this.boundaryCurve.boundingBox.height;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    transform(t, updateBoundingBox = true) {
        if (this.boundaryCurve != null)
            this.boundaryCurve = this.boundaryCurve.transform(t);
    }
    underCollapsedCluster() {
        return this.node != null && this.node.isUnderCollapsedGraph();
    }
}
GeomNode.minHeight = 2;
GeomNode.minWidth = 3;
//# sourceMappingURL=geomNode.js.map