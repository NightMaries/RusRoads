import { GeomObject } from './geomObject';
import { Rectangle } from './../../math/geometry/rectangle';
import { SmoothedPolyline } from './../../math/geometry/smoothedPolyline';
import { Point } from '../../math/geometry/point';
import { Arrowhead } from './arrowhead';
export class GeomEdge extends GeomObject {
    constructor(edge) {
        super(edge);
        this.targetArrowhead = new Arrowhead();
        this.lineWidth = 1;
    }
    Translate(delta) {
        if (delta.x == 0 && delta.y == 0)
            return;
        // RaiseLayoutChangeEvent(delta);
        if (this.curve != null)
            this.curve.translate(delta);
        if (this.smoothedPolyline != null)
            for (let s = this.smoothedPolyline.headSite, s0 = this.smoothedPolyline.headSite; s != null; s = s.next, s0 = s0.next)
                s.point = s0.point.add(delta);
        if (this.sourceArrowhead != null)
            this.sourceArrowhead.tipPosition = this.sourceArrowhead.tipPosition.add(delta);
        if (this.targetArrowhead != null)
            this.targetArrowhead.tipPosition = this.targetArrowhead.tipPosition.add(delta);
    }
    GetMaxArrowheadLength() {
        let l = 0;
        if (this.sourceArrowhead != null) {
            l = this.sourceArrowhead.length;
        }
        if (this.targetArrowhead != null && this.targetArrowhead.length > l) {
            return this.targetArrowhead.length;
        }
        return l;
    }
    transform(matrix) {
        if (this.curve == null)
            return;
        this.curve = this.curve.transform(matrix);
        if (this.underlyingPolyline != null)
            for (let s = this.underlyingPolyline.headSite, s0 = this.underlyingPolyline.headSite; s != null; s = s.next, s0 = s0.next)
                s.point = matrix.multiplyPoint(s.point);
        if (this.sourceArrowhead != null) {
            this.sourceArrowhead.tipPosition = matrix.multiplyPoint(this.sourceArrowhead.tipPosition);
        }
        if (this.targetArrowhead != null) {
            this.targetArrowhead.tipPosition = matrix.multiplyPoint(this.targetArrowhead.tipPosition);
        }
        if (this.label != null)
            this.label.center = matrix.multiplyPoint(this.label.center);
    }
    get labelBBox() {
        return this.label.boundingBox;
    }
    get edge() {
        return this.attrCont;
    }
    get source() {
        return GeomObject.getGeom(this.edge.source);
    }
    get boundingBox() {
        const rect = Rectangle.mkEmpty();
        if (this.underlyingPolyline != null)
            for (const p of this.underlyingPolyline)
                rect.add(p);
        if (this.curve != null)
            rect.addRecSelf(this.curve.boundingBox);
        if (this.sourceArrowhead != null)
            rect.add(this.sourceArrowhead.tipPosition);
        if (this.targetArrowhead != null)
            rect.add(this.targetArrowhead.tipPosition);
        if (this.edge.label) {
            rect.addRecSelf(this.label.boundingBox);
        }
        const del = this.lineWidth;
        rect.left -= del;
        rect.top += del;
        rect.right += del;
        rect.bottom -= del;
        return rect;
    }
    isInterGraphEdge() {
        return this.edge.isInterGraphEdge();
    }
    get target() {
        return GeomObject.getGeom(this.edge.target);
    }
    toString() {
        return this.source.toString() + '->' + this.target;
    }
    static RouteSelfEdge(boundaryCurve, howMuchToStickOut, t) {
        // we just need to find the box of the corresponding node
        const w = boundaryCurve.boundingBox.width;
        const h = boundaryCurve.boundingBox.height;
        const center = boundaryCurve.boundingBox.center;
        const p0 = new Point(center.x - w / 4, center.y);
        const p1 = new Point(center.x - w / 4, center.y - h / 2 - howMuchToStickOut);
        const p2 = new Point(center.x + w / 4, center.y - h / 2 - howMuchToStickOut);
        const p3 = new Point(center.x + w / 4, center.y);
        t.smoothedPolyline = SmoothedPolyline.mkFromPoints([p0, p1, p2, p3]);
        return t.smoothedPolyline.createCurve();
    }
    underCollapsedCluster() {
        return this.source.underCollapsedCluster() || this.target.underCollapsedCluster();
    }
}
//# sourceMappingURL=geomEdge.js.map