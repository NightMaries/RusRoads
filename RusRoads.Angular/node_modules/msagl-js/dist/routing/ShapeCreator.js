///  Class for creating Shape elements from a Graph.
import { RelativeFloatingPort } from '../layout/core/relativeFloatingPort';
import { ClusterBoundaryPort } from './ClusterBoundaryPort';
import { RelativeShape } from './RelativeShape';
export class ShapeCreator {
    ///  For a given graph finds the obstacles for nodes and clusters, correctly parenting the obstacles
    ///  according to the cluster hierarchy
    ///  <param name="graph">graph with edges to route and nodes/clusters to route around</param>
    ///  <returns>the set of obstacles with correct cluster hierarchy and ports</returns>
    static GetShapes(graph, edges = Array.from(graph.edges())) {
        const nodesToShapes = new Map();
        getShapesUnderGraph(graph, nodesToShapes);
        for (const edge of edges) {
            let shape = nodesToShapes.get(edge.source);
            if (shape) {
                if (edge.sourcePort != null) {
                    shape.Ports.add(edge.sourcePort);
                }
            }
            shape = nodesToShapes.get(edge.target);
            if (shape) {
                if (edge.targetPort != null) {
                    shape.Ports.add(edge.targetPort);
                }
            }
        }
        return Array.from(nodesToShapes.values());
    }
    /**   Creates a shape with a RelativeFloatingPort for the node center, attaches it to the shape and all edges */
    static CreateShapeWithCenterPort(node) {
        //  Assert.assert(ApproximateComparer.Close(node.BoundaryCurve.BoundingBox, node.BoundingBox), "node's curve doesn't fit its bounds!");
        const shape = new RelativeShape(() => node.boundaryCurve);
        const port = RelativeFloatingPort.mk(() => node.boundaryCurve, () => node.center);
        shape.Ports.add(port);
        for (const e of node.inEdges()) {
            ShapeCreator.FixPortAtTarget(port, e);
        }
        for (const e of node.outEdges()) {
            ShapeCreator.FixPortAtSource(port, e);
        }
        for (const e of node.selfEdges()) {
            ShapeCreator.FixPortAtSource(port, e);
            ShapeCreator.FixPortAtTarget(port, e);
        }
        return shape;
    }
    /**   Creates a ClusterBoundaryPort for the cluster boundary, attaches it to the shape and all edges */
    static CreateShapeWithClusterBoundaryPort(node) {
        //  Assert.assert(ApproximateComparer.Close(node.BoundaryCurve.BoundingBox, node.BoundingBox), "node's curve doesn't fit its bounds!");
        /*Assert.assert(node.isGraph)*/
        const shape = new RelativeShape(() => node.boundaryCurve);
        const port = ClusterBoundaryPort.mk(() => node.boundaryCurve, () => node.center);
        shape.Ports.add(port);
        for (const e of node.inEdges()) {
            ShapeCreator.FixPortAtTarget(port, e);
        }
        for (const e of node.outEdges()) {
            ShapeCreator.FixPortAtSource(port, e);
        }
        for (const e of node.selfEdges()) {
            ShapeCreator.FixPortAtSource(port, e);
            ShapeCreator.FixPortAtTarget(port, e);
        }
        return shape;
    }
    static FixPortAtSource(port, e) {
        if (e.sourcePort == null) {
            e.sourcePort = port;
        }
    }
    static FixPortAtTarget(port, e) {
        if (e.targetPort == null) {
            e.targetPort = port;
        }
    }
}
function getShapesUnderGraph(graph, nodesToShapes) {
    for (const n of graph.shallowNodes()) {
        if (n.isGraph) {
            const nShape = ShapeCreator.CreateShapeWithClusterBoundaryPort(n);
            nodesToShapes.set(n, nShape);
            const ng = n;
            if (!ng.graph.isCollapsed) {
                getShapesUnderGraph(ng, nodesToShapes);
                for (const ch of ng.shallowNodes()) {
                    nShape.AddChild(nodesToShapes.get(ch));
                }
            }
        }
        else {
            nodesToShapes.set(n, ShapeCreator.CreateShapeWithCenterPort(n));
        }
    }
}
//# sourceMappingURL=ShapeCreator.js.map