import { Shape } from './shape';
import { GeomEdge } from '../layout/core/geomEdge';
import { Point } from '../math/geometry/point';
import { Algorithm } from '../utils/algorithm';
import { ICurve, Polyline } from '../math/geometry';
import { PolylinePoint } from '../math/geometry/polylinePoint';
import { PointSet } from '../utils/PointSet';
import { RTree } from '../math/geometry/RTree/RTree';
import { PointMap } from '../utils/PointMap';
import { VisibilityGraph } from './visibility/VisibilityGraph';
import { TightLooseCouple } from './TightLooseCouple';
import { VisibilityEdge } from './visibility/VisibilityEdge';
import { RectangleNode } from '../math/geometry/RTree/RectangleNode';
import { BundlingSettings } from './BundlingSettings';
import { CancelToken, GeomGraph } from '..';
import { EdgeRoutingSettings } from './EdgeRoutingSettings';
import { Port } from '../layout/core/port';
import { InteractiveEdgeRouter } from './InteractiveEdgeRouter';
import { PointPairMap } from '../utils/pointPairMap';
import { Cdt } from './ConstrainedDelaunayTriangulation/Cdt';
import { CdtEdge } from './ConstrainedDelaunayTriangulation/CdtEdge';
export declare class SplineRouter extends Algorithm {
    continueOnOverlaps: boolean;
    static debCount: number;
    get ContinueOnOverlaps(): boolean;
    set ContinueOnOverlaps(value: boolean);
    rootShapes: Shape[];
    edges(): IterableIterator<GeomEdge>;
    coneAngle: number;
    tightPadding: number;
    loosePadding: number;
    get LoosePadding(): number;
    set LoosePadding(value: number);
    rootWasCreated: boolean;
    root: Shape;
    visGraph: VisibilityGraph;
    ancestorSets: Map<Shape, Set<Shape>>;
    shapesToTightLooseCouples: Map<Shape, TightLooseCouple>;
    portsToShapes: Map<Port, Shape>;
    portsToEnterableShapes: Map<Port, Set<Shape>>;
    portRTree: RTree<Point, Point>;
    portLocationsToLoosePolylines: PointMap<Polyline>;
    looseRoot: Shape;
    BundlingSettings: BundlingSettings;
    enterableLoose: Map<GeomEdge, Set<Polyline>>;
    enterableTight: Map<GeomEdge, Set<Polyline>>;
    geomGraph: GeomGraph;
    multiEdgesSeparation: number;
    routeMultiEdgesAsBundles: boolean;
    UseEdgeLengthMultiplier: boolean;
    UsePolylineEndShortcutting: boolean;
    UseInnerPolylingShortcutting: boolean;
    AllowedShootingStraightLines: boolean;
    get MultiEdgesSeparation(): number;
    set MultiEdgesSeparation(value: number);
    static mk2(graph: GeomGraph, edgeRoutingSettings: EdgeRoutingSettings): SplineRouter;
    static mk4(graph: GeomGraph, tightTightPadding: number, loosePadding: number, coneAngle: number): SplineRouter;
    static mk5(graph: GeomGraph, tightTightPadding: number, loosePadding: number, coneAngle: number, bundlingSettings: BundlingSettings): SplineRouter;
    constructor(graph: GeomGraph, edges: Array<GeomEdge>, tightPadding?: number, loosePadding?: number, coneAngle?: number, bundlingSettings?: BundlingSettings, cancelToken?: CancelToken);
    _edges: GeomEdge[];
    static mk6(graph: GeomGraph, tightPadding: number, loosePadding: number, coneAngle: number, inParentEdges: Array<GeomEdge>, outParentEdges: Array<GeomEdge>): SplineRouter;
    Initialize(obstacles: Array<Shape>, coneAngleValue: number): void;
    run(): void;
    RouteOnRoot(): void;
    CalculatePortsToEnterableShapes(): void;
    static EdgesAttachedToPortAvoidTheNode(port: Port): boolean;
    SetLoosePolylinesForAnywherePorts(): void;
    BindLooseShapes(): void;
    BindLooseShapesUnderShape(shape: Shape): void;
    CalculateShapeToBoundaries(shape: Shape): void;
    private _overlapsDetected;
    get OverlapsDetected(): boolean;
    set OverlapsDetected(value: boolean);
    get AdjustedLoosePadding(): number;
    GroupEdgesByPassport(): Array<{
        passport: Set<Shape>;
        edges: Array<GeomEdge>;
    }>;
    RouteOnVisGraph(): void;
    RouteEdgesWithTheSamePassport(edgeGeometryGroup: {
        passport: Set<Shape>;
        edges: Iterable<GeomEdge>;
    }, interactiveEdgeRouter: InteractiveEdgeRouter, obstacleShapes: Set<Shape>): void;
    get RouteMultiEdgesAsBundles(): boolean;
    set RouteMultiEdgesAsBundles(value: boolean);
    RouteEdge(interactiveEdgeRouter: InteractiveEdgeRouter, edge: GeomEdge): void;
    ScaleDownLooseHierarchy(interactiveEdgeRouter: InteractiveEdgeRouter, obstacleShapes: Set<Shape>): void;
    RouteMultiEdges(multiEdges: Array<GeomEdge[]>, interactiveEdgeRouter: InteractiveEdgeRouter, parents: Set<Shape>): void;
    SplitOnRegularAndMultiedges(edges: Iterable<GeomEdge>, t: {
        regularEdges: Array<GeomEdge>;
        multiEdges: Array<GeomEdge[]>;
    }): void;
    static RegisterInPortLocationsToEdges(eg: GeomEdge, portLocationPairsToEdges: PointPairMap<Array<GeomEdge>>): void;
    static IsEdgeToParent(e: GeomEdge): boolean;
    CreateInteractiveEdgeRouter(obstacleShapes: Array<Shape>): InteractiveEdgeRouter;
    GetObstaclesFromPassport(passport: Set<Shape>): Set<Shape>;
    GetAllAncestors(passport: Set<Shape>): Set<Shape>;
    GetCommonAncestorsAbovePassport(passport: Set<Shape>): Set<Shape>;
    RouteBundles(): void;
    CreateTheMapToParentLooseShapes(shape: Shape, loosePolylinesToLooseParentShapeMap: Map<ICurve, Shape>): void;
    FindCdtGates(cdt: Cdt): Set<CdtEdge>;
    CalculateEdgeEnterablePolylines(): void;
    GetEdgeEnterablePolylines(edge: GeomEdge, looseEnterable: Set<Polyline>, tightEnterable: Set<Polyline>): void;
    GetEnterablesForShape(shape: Shape, looseEnterable: Set<Polyline>, tightEnterable: Set<Polyline>): void;
    GetTightHierarchy(): RectangleNode<Polyline, Point>;
    GetLooseHierarchy(): RectangleNode<Polyline, Point>;
    ScaleLooseShapesDown(): void;
    EdgePassport(edge: GeomEdge): Set<Shape>;
    AllPorts(): IterableIterator<Port>;
    CalculatePortsToShapes(): void;
    RouteEdgeGeometry(edge: GeomEdge, iRouter: InteractiveEdgeRouter): void;
    KeepOriginalSpline: boolean;
    ArrowHeadRatio: number;
    LineSweeperPorts: Point[];
    AddVisibilityEdgesFromPort(port: Port): IterableIterator<VisibilityEdge>;
    MakeTransparentShapesOfEdgeGeometryAndGetTheShapes(edge: GeomEdge): Array<Shape>;
    LooseShapeOfOriginalShape(s: Shape): Shape;
    LoosePolyOfOriginalShape(s: Shape): Polyline;
    TightPolyOfOriginalShape(s: Shape): Polyline;
    GetTransparentShapes(sourcePort: Port, targetPort: Port, sourceShape: Shape, targetShape: Shape): IterableIterator<Shape>;
    static SetTransparency(shapes: Iterable<Shape>, v: boolean): void;
    IsAncestor(possibleAncestor: Shape, possiblePredecessor: Shape): boolean;
    static CreateLooseObstacleHierarachy(loosePolys: Array<Polyline>): RectangleNode<Polyline, Point>;
    CreateTightObstacleHierarachy(obstacles: Array<Shape>): RectangleNode<Polyline, Point>;
    CalculateVisibilityGraph(): void;
    static ShowVisGraph(fileName: string, tmpVisGraph: VisibilityGraph, obstacles: Array<Polyline>, greenCurves?: Array<ICurve>, redCurves?: Array<ICurve>): void;
    private ProcessHookAnyWherePorts;
    FillVisibilityGraphUnderShape(shape: Shape): void;
    bidirectional: boolean;
    get Bidirectional(): boolean;
    set Bidirectional(value: boolean);
    TryToCreateNewEdgeAndSetIsPassable(edge: VisibilityEdge, looseShape: Shape): void;
    AddBoundaryEdgesToVisGraph(boundary: Polyline): void;
    RemoveInsidePortsAndSplitBoundaryIfNeeded(boundary: Polyline): PointSet;
    static FindPointOnPolylineToInsertAfter(boundary: Polyline, point: Point): PolylinePoint;
    GetOrCreateRoot(): void;
    RemoveRoot(): void;
    static GetAncestorSetsMap(shapes: Array<Shape>): Map<Shape, Set<Shape>>;
    static GetAncestorSet(child: Shape, ancSets: Map<Shape, Set<Shape>>): Set<Shape>;
    static CreatePortsIfNeeded(edges: GeomEdge[]): void;
    static ComputeLooseSplinePadding(nodeSeparation: number, edgePadding: number): number;
}
export declare function routeSplines(gg: GeomGraph, edgesToRoute: GeomEdge[], cancelToken: CancelToken): void;
