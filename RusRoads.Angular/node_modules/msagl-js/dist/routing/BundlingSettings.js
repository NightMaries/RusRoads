export class BundlingSettings {
    constructor() {
        this.capacityOverflowCoefficient = BundlingSettings.DefaultCapacityOverflowCoefficientMultiplier;
        this.RotateBundles = false;
        //  the upper bound of the virtual node radius
        this.MaxHubRadius = 50;
        //  the lower bound of the virtual node radius
        this.MinHubRadius = 0.1;
        this.CreateUnderlyingPolyline = false;
        this.pathLengthImportance = BundlingSettings.DefaultPathLengthImportance;
        this.inkImportance = BundlingSettings.DefaultInkImportance;
        this.edgeSeparation = BundlingSettings.DefaultEdgeSeparation;
        this.angleThreshold = (Math.PI / 180) * 45;
        this.hubRepulsionImportance = 100;
        this.bundleRepulsionImportance = 100;
        this.minimalRatioOfGoodCdtEdges = 0.9;
        this.highestQuality = true;
        //  if is set to true the original spline before the trimming should be kept under the corresponding GeomEdge
        this.KeepOriginalSpline = false;
        //  if set to true then the edges will be routed one on top of each other with no gap inside of a bundle
        this.KeepOverlaps = false;
        //  calculates the routes that just follow the visibility graph
        this.StopAfterShortestPaths = false;
    }
    // this number is muliplied by the overflow penalty cost and by the sum of the LengthImportanceCoefficient
    // and InkImportanceCoefficient, and added to the routing price
    get CapacityOverflowCoefficient() {
        return this.capacityOverflowCoefficient;
    }
    set CapacityOverflowCoefficient(value) {
        this.capacityOverflowCoefficient = value;
    }
    //  the importance of path lengths coefficient
    get PathLengthImportance() {
        return this.pathLengthImportance;
    }
    set PathLengthImportance(value) {
        this.pathLengthImportance = value;
    }
    get InkImportance() {
        return this.inkImportance;
    }
    set InkImportance(value) {
        this.inkImportance = value;
    }
    //  Separation between to neighboring edges within a bundle
    get EdgeSeparation() {
        return this.edgeSeparation;
    }
    set EdgeSeparation(value) {
        this.edgeSeparation = value;
    }
    // if is set to true will be using Cubic Bezie Segments inside of hubs, otherwise will be using Biarcs
    get UseCubicBezierSegmentsInsideOfHubs() {
        return this.useCubicBezierSegmentsInsideOfHubs;
    }
    set UseCubicBezierSegmentsInsideOfHubs(value) {
        this.useCubicBezierSegmentsInsideOfHubs = value;
    }
    // 45 degrees;
    // min angle for gluing edges
    get AngleThreshold() {
        return this.angleThreshold;
    }
    set AngleThreshold(value) {
        this.angleThreshold = value;
    }
    //  the importance of hub repulsion coefficient
    get HubRepulsionImportance() {
        return this.hubRepulsionImportance;
    }
    set HubRepulsionImportance(value) {
        this.hubRepulsionImportance = value;
    }
    //  the importance of bundle repulsion coefficient
    get BundleRepulsionImportance() {
        return this.bundleRepulsionImportance;
    }
    set BundleRepulsionImportance(value) {
        this.bundleRepulsionImportance = value;
    }
    //  minimal ration of cdt edges with satisfied capacity needed to perform bundling
    //  (otherwise bundling will not be executed)
    get MinimalRatioOfGoodCdtEdges() {
        return this.minimalRatioOfGoodCdtEdges;
    }
    set MinimalRatioOfGoodCdtEdges(value) {
        this.minimalRatioOfGoodCdtEdges = value;
    }
    //  speed vs quality of the drawing
    get HighestQuality() {
        return this.highestQuality;
    }
    set HighestQuality(value) {
        this.highestQuality = value;
    }
}
// the default value of CapacityOverflowCoefficient
BundlingSettings.DefaultCapacityOverflowCoefficientMultiplier = 1000;
// the default path lenght importance coefficient
BundlingSettings.DefaultPathLengthImportance = 500;
// the default ink importance
BundlingSettings.DefaultInkImportance = 0.01;
// default edge separation
BundlingSettings.DefaultEdgeSeparation = 0.5;
//# sourceMappingURL=BundlingSettings.js.map