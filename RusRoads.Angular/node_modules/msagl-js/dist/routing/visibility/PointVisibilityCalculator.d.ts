import { Point } from '../..';
import { Polyline } from '../../math/geometry';
import { PolylinePoint } from '../../math/geometry/polylinePoint';
import { BinaryHeapWithComparer } from '../../structs/BinaryHeapWithComparer';
import { RBNode } from '../../structs/RBTree/rbNode';
import { RBTree } from '../../structs/RBTree/rbTree';
import { ActiveEdgeComparerWithRay } from './ActiveEdgeComparerWithRay';
import { Stem } from './Stem';
import { VisibilityGraph } from './VisibilityGraph';
import { VisibilityKind } from './VisibilityKind';
import { VisibilityVertex } from './VisibilityVertex';
export declare class PointVisibilityCalculator {
    activeEdgeComparer: ActiveEdgeComparerWithRay;
    activeSidesTree: RBTree<PolylinePoint>;
    sideNodes: Map<PolylinePoint, RBNode<PolylinePoint>>;
    heapForSorting: BinaryHeapWithComparer<Stem>;
    visibilityGraph: VisibilityGraph;
    visibilityKind: VisibilityKind;
    visibleBoundaries: Map<Polyline, Stem>;
    q: Point;
    qPolylinePoint: PolylinePoint;
    qV: VisibilityVertex;
    get QVertex(): VisibilityVertex;
    set QVertex(value: VisibilityVertex);
    sortedListOfPolypoints: Array<PolylinePoint>;
    holes: Array<Polyline>;
    static CalculatePointVisibilityGraph(listOfHoles: Iterable<Polyline>, visibilityGraph: VisibilityGraph, point: Point, visibilityKind: VisibilityKind): VisibilityVertex;
    FillGraph(): void;
    SortSAndInitActiveSides(): void;
    InitHeapAndInsertActiveSides(): void;
    GetInitialVisibleBoundaryStemsAndInsertActiveSides(): IterableIterator<Stem>;
    RegisterActiveSide(side: PolylinePoint): void;
    constructor(holes: Iterable<Polyline>, visibilityGraph: VisibilityGraph, point: Point, visibilityKind: VisibilityKind);
    Sweep(): void;
    SweepPolylinePoint(v: PolylinePoint): void;
    AddEdge(v: PolylinePoint): void;
    static LineTouchesPolygon(a: Point, p: PolylinePoint): boolean;
    GetOutgoingSide(v: PolylinePoint): PolylinePoint;
    static GetIncomingSide(v: PolylinePoint): PolylinePoint;
    ComputeHoleBoundariesPossiblyVisibleFromQ(): void;
    InitActiveEdgesAndActiveEdgesComparer(): void;
    ComputeVisiblePartOfTheHole(hole: Polyline): void;
    HoleSideIsVisibleFromQ(hole: Polyline, b: PolylinePoint): boolean;
}
