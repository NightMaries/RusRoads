import { Point } from '../../math/geometry/point';
import { Polygon } from './Polygon';
export declare class TangentPair {
    P: Polygon;
    Q: Polygon;
    leftPLeftQ: [number, number];
    leftPRightQ: [number, number];
    lowerBranchOnQ: boolean;
    rightPLeftQ: [number, number];
    rightPRightQ: [number, number];
    upperBranchOnP: boolean;
    constructor(polygonP: Polygon, polygonQ: Polygon);
    LeftFromLineOnP(vertexIndex: number, lineStart: Point, lineEnd: Point): boolean;
    LeftFromLineOnQ(vertexIndex: number, lineStart: Point, lineEnd: Point): boolean;
    PrevOnP(i: number): number;
    PrevOnQ(i: number): number;
    NextOnP(i: number): number;
    NextOnQ(i: number): number;
    MedianOnP(i: number, j: number): number;
    MedianOnQ(i: number, j: number): number;
    ModuleP(p0: number, p1: number): number;
    ModuleQ(q0: number, q1: number): number;
    TangentBetweenBranches(p0: number, p1: number, q0: number, q1: number): [number, number];
    FindDividingBisector(t: {
        bisectorPivot: Point;
        bisectorRay: Point;
        p1: number;
        p2: number;
        q1: number;
        q2: number;
    }): void;
    FindClosestPoints(): {
        pClosest: Point;
        qClosest: Point;
    };
    FindClosestFeatures(m: {
        p1: number;
        p2: number;
        q1: number;
        q2: number;
        pClosest: Point;
        qClosest: Point;
    }): void;
    FindClosestPoints_(t: {
        p1: number;
        p2: number;
        q2: number;
        q1: number;
        pClosest: Point;
        qClosest: Point;
    }): void;
    ChunksAreLong(p2: number, p1: number, q2: number, q1: number): boolean;
    ShrinkChunks(t: {
        p2: number;
        p1: number;
        q2: number;
        q1: number;
    }): void;
    InternalCut(t: {
        p1: number;
        p2: number;
        q1: number;
        q2: number;
    }, mp: number, mq: number, a1: number, a2: number, b1: number, b2: number): boolean;
    GetAnglesAtTheMedian(mp: number, mq: number, mP: Point, mQ: Point, t: {
        a1: number;
        a2: number;
        b1: number;
        b2: number;
    }): void;
    OnlyOneChunkContainsExactlyTwoVertices(t: {
        p2: number;
        p1: number;
        q2: number;
        q1: number;
    }, l: {
        mp: number;
        mq: number;
    }, angles: {
        a1: number;
        b1: number;
        a2: number;
        b2: number;
    }): boolean;
    SwapEverything(t: {
        p2: number;
        p1: number;
        q2: number;
        q1: number;
    }, l: {
        mp: number;
        mq: number;
    }, angles: {
        a1: number;
        b1: number;
        a2: number;
        b2: number;
    }): void;
    ProcessShortSide(t: {
        p2: number;
        p1: number;
        q2: number;
        q1: number;
    }, mp: number, mq: number, a1: number, b1: number, a2: number, b2: number): void;
    SwapPq(): void;
    ProcessSide(t: {
        p2: number;
        p1: number;
        q2: number;
        q1: number;
    }, mq: number, a1: number, b1: number, b2: number): void;
    static OneOfChunksContainsOnlyOneVertex(t: {
        p2: number;
        p1: number;
        q2: number;
        q1: number;
    }, mp: number, mq: number, a1: number, b1: number): boolean;
    CalculateLeftTangents(): void;
    CalculateRightTangents(): void;
}
