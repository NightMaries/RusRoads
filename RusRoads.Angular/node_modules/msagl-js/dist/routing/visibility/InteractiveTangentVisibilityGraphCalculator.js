import { Point } from '../..';
import { TriangleOrientation } from '../../math/geometry/point';
import { RBTree } from '../../structs/RBTree/rbTree';
import { TangentPair } from './TangentPair';
import { VisibilityGraph } from './VisibilityGraph';
import { Algorithm } from '../../utils/algorithm';
import { Diagonal } from './Diagonal';
import { Tangent } from './Tangent';
import { ActiveDiagonalComparerWithRay } from './ActiveDiagonalComparerWithRay';
import { StemStartPointComparer } from './StemStartPointComparer';
export class InteractiveTangentVisibilityGraphCalculator extends Algorithm {
    constructor(holes, addedPolygons, visibilityGraph) {
        super(null); // TODO: add cancelToken
        this.activeDiagonalComparer = new ActiveDiagonalComparerWithRay();
        this.polygons = holes;
        this.visibilityGraph = visibilityGraph;
        this.addedPolygons = addedPolygons;
    }
    //  we calculate tangents between activePolygons and between activePolygons and existingObsacles
    run() {
        this.useLeftPTangents = true;
        this.CalculateAndAddEdges();
        // use another family of tangents
        this.useLeftPTangents = false;
        this.CalculateAndAddEdges();
    }
    CalculateAndAddEdges() {
        for (const p of this.addedPolygons) {
            this.CalculateVisibleTangentsFromPolygon(p);
        }
        this.ProgressStep();
    }
    CalculateVisibleTangentsFromPolygon(polygon) {
        this.currentPolygon = polygon;
        this.AllocateDataStructures();
        this.OrganizeTangents();
        this.InitActiveDiagonals();
        this.Sweep();
    }
    AllocateDataStructures() {
        this.tangents = new Array();
        this.diagonals = new Array();
        this.activeDiagonalTree = new RBTree(this.activeDiagonalComparer.Compare.bind(this.activeDiagonalComparer));
    }
    Sweep() {
        if (this.tangents.length < 2) {
            return;
        }
        for (let i = 1; i < this.tangents.length; i++) {
            // we processed the first element already
            const t = this.tangents[i];
            if (t.Diagonal != null) {
                if (t.Diagonal.RbNode == this.activeDiagonalTree.treeMinimum()) {
                    this.AddVisibleEdge(t);
                }
                if (t.IsHigh) {
                    this.RemoveDiagonalFromActiveNodes(t.Diagonal);
                }
            }
            else if (t.IsLow) {
                this.activeDiagonalComparer.PointOnTangentAndInsertedDiagonal = t.End.point;
                this.InsertActiveDiagonal(new Diagonal(t, t.Comp));
                if (t.Diagonal.RbNode == this.activeDiagonalTree.treeMinimum()) {
                    this.AddVisibleEdge(t);
                }
            }
        }
    }
    AddVisibleEdge(t) {
        VisibilityGraph.AddEdgeVV(getVertex(this.visibilityGraph, t.start), getVertex(this.visibilityGraph, t.End));
    }
    //  this function will also add the first tangent to the visible edges if needed
    InitActiveDiagonals() {
        if (this.tangents.length == 0) {
            return;
        }
        const firstTangent = this.tangents[0];
        const firstTangentStart = firstTangent.start.point;
        const firstTangentEnd = firstTangent.End.point;
        for (const diagonal of this.diagonals) {
            if (InteractiveTangentVisibilityGraphCalculator.RayIntersectDiagonal(firstTangentStart, firstTangentEnd, diagonal)) {
                this.activeDiagonalComparer.PointOnTangentAndInsertedDiagonal = ActiveDiagonalComparerWithRay.IntersectDiagonalWithRay(firstTangentStart, firstTangentEnd, diagonal);
                this.InsertActiveDiagonal(diagonal);
            }
            if (firstTangent.Diagonal.RbNode == this.activeDiagonalTree.treeMinimum()) {
                this.AddVisibleEdge(firstTangent);
            }
            if (firstTangent.IsLow == false) {
                // remove the diagonal of the top tangent from active edges
                const diag = firstTangent.Diagonal;
                this.RemoveDiagonalFromActiveNodes(diag);
            }
        }
    }
    RemoveDiagonalFromActiveNodes(diag) {
        const changedNode = this.activeDiagonalTree.deleteSubTree(diag.RbNode);
        if (changedNode != null) {
            if (changedNode.item != null) {
                changedNode.item.RbNode = changedNode;
            }
        }
        diag.LeftTangent.Diagonal = null;
        diag.RightTangent.Diagonal = null;
    }
    InsertActiveDiagonal(diagonal) {
        diagonal.RbNode = this.activeDiagonalTree.insert(diagonal);
        InteractiveTangentVisibilityGraphCalculator.MarkDiagonalAsActiveInTangents(diagonal);
    }
    static MarkDiagonalAsActiveInTangents(diagonal) {
        diagonal.LeftTangent.Diagonal = diagonal;
        diagonal.RightTangent.Diagonal = diagonal;
    }
    static RayIntersectDiagonal(pivot, pointOnRay, diagonal) {
        const a = diagonal.Start;
        const b = diagonal.End;
        return (Point.getTriangleOrientation(pivot, a, b) == TriangleOrientation.Counterclockwise &&
            Point.getTriangleOrientation(pivot, pointOnRay, a) != TriangleOrientation.Counterclockwise &&
            Point.getTriangleOrientation(pivot, pointOnRay, b) != TriangleOrientation.Clockwise);
    }
    //  compare tangents by measuring the counterclockwise angle between the tangent and the edge
    static TangentComparison(e0, e1) {
        return StemStartPointComparer.CompareVectorsByAngleToXAxis(e0.End.point.sub(e0.start.point), e1.End.point.sub(e1.start.point));
    }
    *AllObstacles() {
        for (const p of this.addedPolygons) {
            yield p;
        }
        for (const p of this.polygons) {
            yield p;
        }
    }
    OrganizeTangents() {
        for (const q of this.AllObstacles()) {
            if (q != this.currentPolygon) {
                this.ProcessPolygonQ(q);
            }
        }
        this.tangents.sort(InteractiveTangentVisibilityGraphCalculator.TangentComparison);
    }
    ProcessPolygonQ(q) {
        const tangentPair = new TangentPair(this.currentPolygon, q);
        if (this.useLeftPTangents) {
            tangentPair.CalculateLeftTangents();
        }
        else {
            tangentPair.CalculateRightTangents();
        }
        let couple = this.useLeftPTangents ? tangentPair.leftPLeftQ : tangentPair.rightPLeftQ;
        const t0 = new Tangent(this.currentPolygon.pp(couple[0]), q.pp(couple[1]));
        t0.IsLow = true;
        t0.SeparatingPolygons = !this.useLeftPTangents;
        couple = this.useLeftPTangents ? tangentPair.leftPRightQ : tangentPair.rightPRightQ;
        const t1 = new Tangent(this.currentPolygon.pp(couple[0]), q.pp(couple[1]));
        t1.IsLow = false;
        t1.SeparatingPolygons = this.useLeftPTangents;
        t0.Comp = t1;
        t1.Comp = t0;
        this.tangents.push(t0);
        this.tangents.push(t1);
        this.diagonals.push(new Diagonal(t0, t1));
    }
}
function getVertex(vg, pp) {
    return vg.FindVertex(pp.point);
}
//# sourceMappingURL=InteractiveTangentVisibilityGraphCalculator.js.map