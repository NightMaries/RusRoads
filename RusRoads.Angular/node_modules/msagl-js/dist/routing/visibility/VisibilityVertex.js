import { RBTree } from './../../structs/RBTree/rbTree';
export class VisibilityVertex {
    constructor(point) {
        this._inEdges = new Array();
        this._outEdges = new RBTree((a, b) => this.Compare(a, b));
        this.point = point;
    }
    get InEdges() {
        return this._inEdges;
    }
    //  this collection is sorted by the target point, in the lexicographical order
    get OutEdges() {
        return this._outEdges;
    }
    get Degree() {
        return this._inEdges.length + this.OutEdges.count;
    }
    InEdgesLength() {
        return this._inEdges.length;
    }
    addInEdge(e) {
        this._inEdges.push(e);
    }
    get IsTerminal() {
        return this._isTerminal;
    }
    set IsTerminal(value) {
        this._isTerminal = value;
    }
    get IsShortestPathTerminal() {
        return this._isShortestPathTerminal;
    }
    set IsShortestPathTerminal(value) {
        this._isShortestPathTerminal = value;
    }
    toString() {
        return this.point.toString();
    }
    //  These iterate from the end of the list because Array.Remove is linear in
    //  the number of items, so callers have been optimized where possible to
    //  remove only the last or next-to-last edges (but in some cases such as
    //  rectilinear, this optimization isn't always possible).
    RemoveOutEdge(edge) {
        this.OutEdges.remove(edge);
    }
    RemoveInEdge(edge) {
        // eslint-disable-next-line for-direction
        const i = this._inEdges.indexOf(edge);
        if (i == -1)
            return;
        const last = this._inEdges.length - 1;
        if (i != last) {
            this._inEdges[i] = this._inEdges[last];
        }
        this._inEdges.pop();
    }
    //  avoiding using delegates in calling RBTree.FindFirst because of the memory allocations
    static FindFirst(tree, targetPoint) {
        return VisibilityVertex.FindFirst_t(tree.root, tree, targetPoint);
    }
    static FindFirst_t(n, tree, targetPoint) {
        if (n == tree.nil) {
            return null;
        }
        let ret = null;
        while (n != tree.nil) {
            n = n.item.TargetPoint.compareTo(targetPoint) >= 0 ? (ret = n).left : n.right;
        }
        return ret;
    }
    get(target) {
        let node = VisibilityVertex.FindFirst(this.OutEdges, target.point);
        if (node != null) {
            if (node.item.Target == target) {
                return node.item;
            }
        }
        node = VisibilityVertex.FindFirst(target.OutEdges, this.point);
        if (node != null) {
            if (node.item.Target == this) {
                return node.item;
            }
        }
        return null;
    }
    Compare(a, b) {
        return a.TargetPoint.compareTo(b.TargetPoint);
    }
    ClearEdges() {
        this._outEdges.clear();
        this._inEdges = [];
    }
}
//# sourceMappingURL=VisibilityVertex.js.map