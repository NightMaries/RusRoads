import { Point, ICurve } from '../../..';
import { Polyline } from '../../../math/geometry';
import { Ellipse } from '../../../math/geometry/ellipse';
import { PolylinePoint } from '../../../math/geometry/polylinePoint';
import { RBNode } from '../../../structs/RBTree/rbNode';
import { RBTree } from '../../../structs/RBTree/rbTree';
import { LineSweeperBase } from '../../visibility/LineSweeperBase';
import { PortObstacleEvent } from '../../visibility/PortObstacleEvent';
import { VisibilityGraph } from '../../visibility/VisibilityGraph';
import { BrokenConeSide } from './BrokenConeSide';
import { Cone } from './Cone';
import { ConeLeftSide } from './ConeLeftSide';
import { ConeRightSide } from './ConeRightSide';
import { ConeSide } from './ConeSide';
import { ConeSideComparer } from './ConeSideComparer';
import { LeftIntersectionEvent } from './LeftIntersectionEvent';
import { ObstacleSide } from './ObstacleSide';
import { PortLocationEvent } from './PortLocationEvent';
import { RightIntersectionEvent } from './RightIntersectionEvent';
import { RightVertexEvent } from './RightVertexEvent';
import { SweepEvent } from './SweepEvent';
import { VertexEvent } from './VertexEvent';
export declare class LineSweeperForPortLocations extends LineSweeperBase {
    ConeRightSideDirection: Point;
    ConeLeftSideDirection: Point;
    coneSideComparer: ConeSideComparer;
    visibilityGraph: VisibilityGraph;
    rightConeSides: RBTree<ConeSide>;
    leftConeSides: RBTree<ConeSide>;
    constructor(obstacles: Array<Polyline>, direction: Point, coneRsDir: Point, coneLsDir: Point, visibilityGraph: VisibilityGraph, portLocations: Array<Point>);
    PortLocations: Array<Point>;
    static Sweep(obstacles: Array<Polyline>, direction: Point, coneAngle: number, visibilityGraph: VisibilityGraph, portLocations: Array<Point>): void;
    Calculate(): void;
    ProcessEvent(p: SweepEvent): void;
    ProcessPointObstacleEvent(portObstacleEvent: PortObstacleEvent): void;
    CreateConeOnPortLocation(sweepEvent: SweepEvent): void;
    ProcessPortLocationEvent(portEvent: PortLocationEvent): void;
    ProcessLeftIntersectionEvent(leftIntersectionEvent: LeftIntersectionEvent): void;
    TryCreateConeClosureForLeftSide(leftSide: BrokenConeSide): void;
    CreateConeClosureEvent(brokenConeSide: BrokenConeSide, otherSide: ConeSide): void;
    ProcessRightIntersectionEvent(rightIntersectionEvent: RightIntersectionEvent): void;
    TryCreateConeClosureForRightSide(rightSide: BrokenConeSide): void;
    RemoveConesClosedBySegment(leftPoint: Point, rightPoint: Point): void;
    CloseConesCoveredBySegment(leftPoint: Point, rightPoint: Point, tree: RBTree<ConeSide>): void;
    ProcessVertexEvent(vertexEvent: VertexEvent): void;
    static EllipseOnVert(vertexEvent: SweepEvent): Ellipse;
    static EllipseOnPolylinePoint(pp: PolylinePoint): Ellipse;
    ExtendSegmentToZ(segment: ConeSide): ICurve;
    AddConeAndEnqueueEvents(vertexEvent: VertexEvent): void;
    CloseConesAtRightVertex(rightVertexEvent: VertexEvent, nextVertex: PolylinePoint): void;
    CaseToTheLeftOfLineOrOnLineConeRp(rightVertexEvent: VertexEvent, nextVertex: PolylinePoint): void;
    LookForIntersectionOfObstacleSideAndRightConeSide(obstacleSideStart: Point, obstacleSideVertex: PolylinePoint): void;
    CreateRightIntersectionEvent(coneRightSide: ConeRightSide, intersection: Point, obstacleSideVertex: PolylinePoint): RightIntersectionEvent;
    GetLastNodeToTheLeftOfPointInRightSegmentTree(obstacleSideStart: Point): RBNode<ConeSide>;
    LookForIntersectionOfObstacleSideAndLeftConeSide(obstacleSideStart: Point, obstacleSideVertex: PolylinePoint): void;
    GetFirstNodeToTheRightOfPoint(p: Point): RBNode<ConeSide>;
    static PointIsToTheLeftOfSegment(p: Point, seg: ConeSide): boolean;
    static PointIsToTheRightOfSegment(p: Point, seg: ConeSide): boolean;
    FixConeLeftSideIntersections(obstSideStart: PolylinePoint, obstSideEnd: PolylinePoint, rbNode: RBNode<ConeSide>): void;
    InsertToTree(tree: RBTree<ConeSide>, coneSide: ConeSide): RBNode<ConeSide>;
    CloseConesAtLeftVertex(leftVertexEvent: VertexEvent, nextVertex: PolylinePoint): void;
    RemoveCone(cone: Cone): void;
    RemoveSegFromRightTree(coneSide: ConeSide): void;
    RemoveSegFromLeftTree(coneSide: ConeSide): void;
    FixConeRightSideIntersections(obstSideStartVertex: PolylinePoint, obstSideEndVertex: PolylinePoint, rbNode: RBNode<ConeSide>): void;
    LookForIntersectionWithConeLeftSide(leftNode: RBNode<ConeSide>): void;
    LookForIntersectionWithConeRightSide(rightNode: RBNode<ConeSide>): void;
    TryIntersectionOfConeRightSideAndObstacleConeSide(coneRightSide: ConeRightSide, seg: BrokenConeSide): void;
    TryIntersectionOfConeRightSideAndObstacleSide(coneRightSide: ConeRightSide, side: ObstacleSide): void;
    TryIntersectionOfConeLeftSideAndObstacleConeSide(coneLeftSide: ConeLeftSide, seg: BrokenConeSide): void;
    TryIntersectionOfConeLeftSideAndObstacleSide(coneLeftSide: ConeLeftSide, side: ObstacleSide): void;
    GoOverConesSeeingVertexEvent(vertexEvent: SweepEvent): void;
    addEdge(a: Point, b: Point): void;
    static VertexIsToTheLeftOfSegment(vertexEvent: SweepEvent, seg: ConeSide): boolean;
    static VertexIsToTheRightOfSegment(vertexEvent: SweepEvent, seg: ConeSide): boolean;
    FindFirstSegmentInTheRightTreeNotToTheLeftOfVertex(vertexEvent: SweepEvent): RBNode<ConeSide>;
    EnqueueEventLocal(vertexEvent: RightVertexEvent): void;
}
