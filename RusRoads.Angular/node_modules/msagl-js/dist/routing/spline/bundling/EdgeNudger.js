import { Point } from '../../..';
import { Curve, LineSegment, GeomConstants, CurveFactory } from '../../../math/geometry';
import { BezierSeg } from '../../../math/geometry/bezierSeg';
import { DebugCurve } from '../../../math/geometry/debugCurve';
import { Ellipse } from '../../../math/geometry/ellipse';
import { distPP } from '../../../math/geometry/point';
import { Algorithm } from '../../../utils/algorithm';
import { BundleBasesCalculator } from './BundleBasesCalculator';
import { HubRadiiCalculator } from './HubRadiiCalculator';
import { GeneralMetroMapOrdering } from './GeneralMetroMapOrdering';
/** this class nudges the edges */
export class EdgeNudger extends Algorithm {
    //  Constructor
    constructor(metroGraphData, bundlingSettings) {
        super(null);
        this.metroGraphData = metroGraphData;
        this.bundlingSettings = bundlingSettings;
    }
    run() {
        this.CreateMetroOrdering();
        this.InitRadii();
        this.FinalizePaths();
    }
    InitRadii() {
        new HubRadiiCalculator(this.metroGraphData, this.bundlingSettings).CreateNodeRadii();
    }
    //  bundle-map ordering
    CreateMetroOrdering() {
        this.metroOrdering = new GeneralMetroMapOrdering(this.metroGraphData.Metrolines);
    }
    FinalizePaths() {
        this.CreateBundleBases();
        this.CreateSegmentsInsideHubs();
        this.CreateCurves();
    }
    CreateBundleBases() {
        const bbCalc = new BundleBasesCalculator(this.metroOrdering, this.metroGraphData, this.bundlingSettings);
        bbCalc.Run();
    }
    CreateCurves() {
        //Assert.assert(this.metroGraphData.Metrolines.length == this.metroGraphData.Edges.length)
        for (let i = 0; i < this.metroGraphData.Metrolines.length; i++) {
            this.CreateCurveLine(this.metroGraphData.Metrolines[i], this.metroGraphData.Edges[i]);
        }
    }
    CreateCurveLine(line, edge) {
        const c = new Curve();
        const start = EdgeNudger.FindCurveStart(this.metroGraphData, this.metroOrdering, line);
        let currentEnd = start;
        const hubSegsOfLine = EdgeNudger.HubSegsOfLine(this.metroGraphData, this.metroOrdering, line);
        for (const seg of hubSegsOfLine) {
            if (seg == null) {
                continue;
            }
            c.addSegment(LineSegment.mkPP(currentEnd, seg.start));
            c.addSegment(seg);
            currentEnd = seg.end;
        }
        c.addSegment(LineSegment.mkPP(currentEnd, EdgeNudger.FindCurveEnd(this.metroGraphData, this.metroOrdering, line)));
        edge.curve = c;
    }
    static FindCurveStart(metroGraphData, metroOrdering, metroline) {
        const u = metroGraphData.PointToStations.get(metroline.Polyline.startPoint.point);
        const v = metroGraphData.PointToStations.get(metroline.Polyline.startPoint.next.point);
        const bb = u.BundleBases.get(v);
        const index = !bb.IsParent
            ? metroOrdering.GetLineIndexInOrder(v, u, metroline)
            : metroOrdering.GetLineIndexInOrder(u, v, metroline);
        return bb.Points[index];
    }
    static FindCurveEnd(metroGraphData, metroOrdering, metroline) {
        const u = metroGraphData.PointToStations.get(metroline.Polyline.endPoint.prev.point);
        const v = metroGraphData.PointToStations.get(metroline.Polyline.endPoint.point);
        const bb = v.BundleBases.get(u);
        const index = !bb.IsParent ? metroOrdering.GetLineIndexInOrder(u, v, metroline) : metroOrdering.GetLineIndexInOrder(v, u, metroline);
        return bb.Points[index];
    }
    static *HubSegsOfLine(metroGraphData, metroOrdering, line) {
        for (let i = line.Polyline.startPoint.next; i.next != null; i = i.next)
            yield EdgeNudger.SegOnLineVertex(metroGraphData, metroOrdering, line, i);
    }
    static SegOnLineVertex(metroGraphData, metroOrdering, line, i) {
        const u = metroGraphData.PointToStations.get(i.prev.point);
        const v = metroGraphData.PointToStations.get(i.point);
        const h0 = v.BundleBases.get(u);
        const j0 = metroOrdering.GetLineIndexInOrder(u, v, line);
        if (h0.OrientedHubSegments[j0] == null || h0.OrientedHubSegments[j0].Segment == null) {
            const w = metroGraphData.PointToStations.get(i.next.point);
            const otherBase = v.BundleBases.get(w);
            const j1 = metroOrdering.GetLineIndexInOrder(w, v, line);
            return LineSegment.mkPP(h0.Points[j0], otherBase.Points[j1]);
        }
        return h0.OrientedHubSegments[j0].Segment;
    }
    CreateSegmentsInsideHubs() {
        for (const metroline of this.metroGraphData.Metrolines) {
            this.CreateOrientedSegsOnLine(metroline);
        }
        if (this.bundlingSettings.UseCubicBezierSegmentsInsideOfHubs) {
            this.FanBezierSegs();
        }
    }
    CreateOrientedSegsOnLine(line) {
        for (let polyPoint = line.Polyline.startPoint.next; polyPoint.next != null; polyPoint = polyPoint.next) {
            this.CreateOrientedSegsOnLineVertex(line, polyPoint);
        }
    }
    CreateOrientedSegsOnLineVertex(line, polyPoint) {
        const u = this.metroGraphData.PointToStations.get(polyPoint.prev.point);
        const v = this.metroGraphData.PointToStations.get(polyPoint.point);
        const w = this.metroGraphData.PointToStations.get(polyPoint.next.point);
        const h0 = v.BundleBases.get(u);
        const h1 = v.BundleBases.get(w);
        const j0 = this.metroOrdering.GetLineIndexInOrder(u, v, line);
        const j1 = this.metroOrdering.GetLineIndexInOrder(w, v, line);
        const seg = this.bundlingSettings.UseCubicBezierSegmentsInsideOfHubs
            ? EdgeNudger.StandardBezier(h0.Points[j0], h0.Tangents[j0], h1.Points[j1], h1.Tangents[j1])
            : EdgeNudger.BiArc(h0.Points[j0], h0.Tangents[j0], h1.Points[j1], h1.Tangents[j1]);
        h0.OrientedHubSegments[j0].Segment = seg;
        h1.OrientedHubSegments[j1].Segment = seg;
    }
    static ShowHubs(metroGraphData, metroMapOrdering, station, fileName, moreCurves = []) {
        let ttt = EdgeNudger.GetAllDebugCurves(metroMapOrdering, metroGraphData);
        if (station != null) {
            ttt.push(DebugCurve.mkDebugCurveTWCI(255, 1, 'red', CurveFactory.CreateDiamond(5, 25, station.Position)));
        }
        ttt = ttt.concat(moreCurves);
        // SvgDebugWriter.dumpDebugCurves(fileName, ttt) // uncomment this line to get the SVG output
    }
    static GetAllDebugCurves(metroMapOrdering, metroGraphData) {
        return EdgeNudger.GraphNodes(metroGraphData)
            .concat(EdgeNudger.VertexDebugCurves(metroMapOrdering, metroGraphData))
            .concat(EdgeNudger.DebugEdges(metroGraphData));
    }
    static DebugEdges(metroGraphData1) {
        return metroGraphData1.Edges.map((e) => DebugCurve.mkDebugCurveTWCI(40, 0.1, 'gray', e.curve));
    }
    static VertexDebugCurves(metroMapOrdering, metroGraphData) {
        return EdgeNudger.DebugCircles(metroGraphData)
            .concat(EdgeNudger.DebugHubBases(metroGraphData))
            .concat(EdgeNudger.DebugSegs(metroGraphData))
            .concat(EdgeNudger.BetweenHubs(metroMapOrdering, metroGraphData));
    }
    static BetweenHubs(metroMapOrdering, metroGraphData) {
        const ret = [];
        for (const ml of metroGraphData.Metrolines) {
            const segs = EdgeNudger.GetInterestingSegs(metroGraphData, metroMapOrdering, ml);
            const color = EdgeNudger.GetMonotoneColor(ml.Polyline.start, ml.Polyline.end, segs);
            for (const seg of segs) {
                ret.push(DebugCurve.mkDebugCurveTWCI(100, ml.Width, color, LineSegment.mkPP(seg[0], seg[1])));
            }
        }
        return ret;
    }
    static GetInterestingSegs(metroGraphData, metroMapOrdering, line) {
        const ret = new Array();
        if (metroGraphData.Stations.length == 0 ||
            metroGraphData.Stations[0].BundleBases == null ||
            metroGraphData.Stations[0].BundleBases.size == 0)
            return [];
        let start = EdgeNudger.FindCurveStart(metroGraphData, metroMapOrdering, line);
        const cubicSegs = EdgeNudger.HubSegsOfLine(metroGraphData, metroMapOrdering, line);
        for (const seg of cubicSegs) {
            if (seg == null) {
                continue;
            }
            ret.push([start, seg.start]);
            start = seg.end;
        }
        ret.push([start, EdgeNudger.FindCurveEnd(metroGraphData, metroMapOrdering, line)]);
        return ret;
    }
    static GetMonotoneColor(start, end, segs) {
        return 'green';
        //             Point dir = end - start;
        //             bool monotone = segs.All(seg => (seg.Second - seg.First)*dir >= 0);
        //             return monotone ? "green" : "magenta";
    }
    static DebugHubBases(metroGraphData) {
        const dc = new Array();
        for (const s of metroGraphData.Stations) {
            for (const h of s.BundleBases.values()) {
                dc.push(DebugCurve.mkDebugCurveTWCI(100, 1, 'red', LineSegment.mkPP(h.LeftPoint, h.RightPoint)));
            }
        }
        return dc;
        // return
        //     metroGraphData.Stations.SelectMany(s => s.BundleBases.Values).Select(
        //         h => new DebugCurve(100, 0.01, "red", new LineSegment(h.Points[0], h.Points.Last())));
    }
    static DebugCircles(metroGraphData) {
        return metroGraphData.Stations.map((station) => DebugCurve.mkDebugCurveTWCI(100, 0.1, 'blue', CurveFactory.mkCircle(station.Radius, station.Position)));
    }
    static DebugSegs(metroGraphData) {
        const ls = new Array();
        for (const s of metroGraphData.VirtualStations()) {
            for (const b of s.BundleBases.values()) {
                for (const h of b.OrientedHubSegments) {
                    if (h == null) {
                        continue;
                    }
                    if (h.Segment == null) {
                        const uBase = h.Other.BundleBase;
                        const i = h.Index;
                        const j = h.Other.Index;
                        ls.push(LineSegment.mkPP(b.Points[i], uBase.Points[j]));
                    }
                    else {
                        ls.push(h.Segment);
                    }
                }
            }
        }
        return ls.map((s) => DebugCurve.mkDebugCurveTWCI(100, 0.01, 'green', s));
    }
    static GraphNodes(metroGraphData) {
        const nodes = metroGraphData.Edges.map((e) => e.sourcePort.Curve).concat(metroGraphData.Edges.map((e) => e.targetPort.Curve));
        return nodes.map((n) => DebugCurve.mkDebugCurveTWCI(40, 1, 'black', n));
    }
    static BiArc(p0, ts, p4, te) {
        //Assert.assert(closeDistEps(ts.lengthSquared, 1))
        //Assert.assert(closeDistEps(te.lengthSquared, 1))
        const v = p0.sub(p4);
        if (v.length < GeomConstants.distanceEpsilon)
            return null;
        const vtse = v.dot(ts.sub(te));
        const tste = -ts.dot(te);
        //solving a quadratic equation
        const a = 2 * (tste - 1);
        const b = 2 * vtse;
        const c = v.dot(v);
        let al;
        if (Math.abs(a) < GeomConstants.distanceEpsilon) {
            //we have b*al+c=0
            if (Math.abs(b) > GeomConstants.distanceEpsilon) {
                al = -c / b;
            }
            else {
                return null;
            }
        }
        else {
            let d = b * b - 4 * a * c;
            //Assert.assert(d >= -GeomConstants.tolerance)
            if (d < 0)
                d = 0;
            d = Math.sqrt(d);
            al = (-b + d) / (2 * a);
            if (al < 0)
                al = (-b - d) / (2 * a);
        }
        const p1 = p0.add(ts.mul(al));
        const p3 = p4.add(te.mul(al));
        const p2 = Point.middle(p1, p3);
        const curve = new Curve();
        curve.addSegs([EdgeNudger.ArcOn(p0, p1, p2), EdgeNudger.ArcOn(p2, p3, p4)]);
        //bad input for BiArc. we shouldn't allow such cases during bundle bases construction
        if (ts.dot(p4.sub(p0)) <= 0 && ts.dot(te) <= 0) {
            //switch to Bezier
            const curve2 = EdgeNudger.StandardBezier(p0, ts, p4, te);
            // #if TEST_MSAGL
            //                 /*List<DebugCurve> dc = new List<DebugCurve>();
            //                 dc.Add(new DebugCurve(curve));
            //                 dc.Add(new DebugCurve(0.3, "black", curve2));
            //                 dc.Add(new DebugCurve(0.1, "red", new LineSegment(p0, p0 + 3 * ts)));
            //                 dc.Add(new DebugCurve(0.1, "blue", new LineSegment(p4, p4 + 3 * te)));
            //                 LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(dc);*/
            // #endif
            return curve2;
        }
        return curve;
    }
    //  returns the arc that a,b,c touches
    static ArcOn(a, b, c) {
        const t = { center: null };
        if (Math.abs(Point.signedDoubledTriangleArea(a, b, c)) < 0.0001 || !EdgeNudger.FindArcCenter(a, b, c, t)) {
            return LineSegment.mkPP(a, c);
        }
        const center = t.center;
        const radius = distPP(a, center);
        const chordLength = distPP(a, b);
        if (chordLength / radius < 0.0001) {
            return LineSegment.mkPP(a, c);
        }
        const cenA = a.sub(center);
        let aAngle = Math.atan2(cenA.y, cenA.x);
        const cenC = c.sub(center);
        let cAngle = Math.atan2(cenC.y, cenC.x);
        let delac = cAngle - aAngle;
        if (delac < 0) {
            delac += 2 * Math.PI;
            cAngle += 2 * Math.PI;
        }
        if (delac <= Math.PI) {
            // going ccw
            const el = new Ellipse(aAngle, cAngle, new Point(radius, 0), new Point(0, radius), center);
            return el;
        }
        // going clockwise
        if (cAngle > 2 * Math.PI) {
            cAngle -= 2 * Math.PI;
        }
        aAngle = Math.PI - aAngle;
        cAngle = Math.PI - cAngle;
        if (aAngle < 0) {
            aAngle += 2 * Math.PI;
        }
        while (cAngle < aAngle) {
            cAngle += 2 * Math.PI;
        }
        delac = cAngle - aAngle;
        //Assert.assert(delac <= Math.PI)
        return new Ellipse(aAngle, cAngle, new Point(-radius, 0), new Point(0, radius), center);
    }
    static FindArcCenter(a, b, c, t) {
        const perp0 = b.sub(a).rotate90Cw();
        const perp1 = b.sub(c).rotate90Cw();
        t.center = Point.lineLineIntersection(a, a.add(perp0), c, c.add(perp1));
        return t.center != null;
    }
    static StandardBezier(segStart, tangentAtStart, segEnd, tangentAtEnd) {
        const len = distPP(segStart, segEnd) / 4;
        return BezierSeg.mkBezier([segStart, segStart.add(tangentAtStart.mul(len)), segEnd.add(tangentAtEnd.mul(len)), segEnd]);
    }
    FanBezierSegs() {
        let progress = true;
        const maxSteps = 5;
        let steps = 0;
        while (progress && steps++ < maxSteps) {
            progress = false;
            for (const s of this.metroGraphData.Stations)
                for (const segmentHub of s.BundleBases.values())
                    progress || (progress = this.FanEdgesOfHubSegment(segmentHub));
        }
    }
    FanEdgesOfHubSegment(bundleHub) {
        let ret = false;
        for (let i = 0; i < bundleHub.Count - 1; i++) {
            ret || (ret = this.FanCouple(bundleHub, i, bundleHub.CurveCenter, bundleHub.Curve.boundingBox.diagonal / 2));
        }
        return ret;
    }
    //  fans the couple i,i+1
    FanCouple(bundleHub, i, center, radius) {
        const lSeg = bundleHub.OrientedHubSegments[i];
        const rSeg = bundleHub.OrientedHubSegments[i + 1];
        if (lSeg == null) {
            return false;
        }
        const x = LineSegment.IntersectPPPP(lSeg.Segment.start, lSeg.Segment.end, rSeg.Segment.start, rSeg.Segment.end);
        if (x) {
            // it doesn not make sense to push these segs apart
            return false;
        }
        if (Point.getTriangleOrientation(lSeg.value(0), lSeg.value(0.5), lSeg.value(1)) !=
            Point.getTriangleOrientation(rSeg.value(0), rSeg.value(0.5), rSeg.value(1))) {
            return false;
        }
        const ll = this.BaseLength(lSeg);
        const rl = this.BaseLength(rSeg);
        if (Math.abs(ll - rl) < GeomConstants.intersectionEpsilon) {
            return false;
        }
        if (ll > rl) {
            return this.AdjustLongerSeg(lSeg, rSeg, center, radius);
        }
        return this.AdjustLongerSeg(rSeg, lSeg, center, radius);
    }
    AdjustLongerSeg(longerSeg, shorterSeg, center, radius) {
        const del0 = longerSeg.value(0).sub(shorterSeg.value(0));
        const del1 = longerSeg.value(1).sub(shorterSeg.value(1));
        const minDelLength = Math.min(del0.length, del1.length);
        const midPointOfShorter = shorterSeg.value(0.5);
        const maxDelLen = Math.max(del0.length, del1.length);
        if (this.NicelyAligned(longerSeg.Segment, del0, del1, midPointOfShorter, minDelLength, maxDelLen) == 0) {
            return false;
        }
        return this.FitLonger(longerSeg, del0, del1, midPointOfShorter, minDelLength, maxDelLen, center, radius);
    }
    FitLonger(longerOrientedSeg, del0, del1, midPointOfShorter, minDelLength, maxDel, center, radius) {
        let seg = longerOrientedSeg.Segment;
        const start = seg.start;
        const end = seg.end;
        //  LayoutAlgorithmSettings.ShowDebugCurves(new DebugCurve("green", shorterDebugOnly), new DebugCurve("red", seg));
        let steps = 0;
        const maxSteps = 10;
        let lowP1 = seg.start.mul(1 - EdgeNudger.SqueezeBound).add(seg.B(1).mul(EdgeNudger.SqueezeBound));
        let lowP2 = seg.end.mul(1 - EdgeNudger.SqueezeBound).add(seg.B(2).mul(EdgeNudger.SqueezeBound));
        let highP1 = seg.B(1).mul(2).sub(seg.start);
        // originally the tangents were 0.25 of the length of seg[1]-seg[0] - so were are safe to lengthen two times
        let highP2 = seg.B(2).mul(2).sub(seg.end);
        const t = { highP: highP1 };
        this.PullControlPointToTheCircle(seg.start, t, center, radius);
        highP1 = t.highP;
        let r = this.NicelyAligned(seg, del0, del1, midPointOfShorter, minDelLength, maxDel);
        do {
            if (r == -1) {
                // pull the control points lower
                const p1 = Point.middle(seg.B(1), lowP1);
                const p2 = Point.middle(seg.B(2), lowP2);
                highP1 = seg.B(1);
                highP2 = seg.B(2);
                seg = new BezierSeg(start, p1, p2, end);
            }
            else {
                //Assert.assert(r == 1)
                // pull the control points higher
                const p1 = Point.middle(seg.B(1), highP1);
                const p2 = (seg.B(2), highP2);
                lowP1 = seg.B(1);
                lowP2 = seg.B(2);
                seg = new BezierSeg(start, p1, p2, end);
            }
            if ((r = this.NicelyAligned(seg, del0, del1, midPointOfShorter, minDelLength, maxDel)) == 0) {
                longerOrientedSeg.Segment = seg;
                longerOrientedSeg.Other.Segment = seg;
                return true;
            }
            if (steps++ > maxSteps)
                return false; //cannot fix it
            // cannot fix it
        } while (true);
    }
    PullControlPointToTheCircle(start, t, center, radius) {
        const closestPointOnLine = Point.ProjectionToLine(start, t.highP, center);
        // the max offset from closestPointOnLine
        const maxOffset = Math.sqrt(radius * radius - closestPointOnLine.sub(center).lengthSquared);
        const offsetNow = t.highP.sub(closestPointOnLine);
        const offsetLen = offsetNow.length;
        if (offsetLen > maxOffset) {
            t.highP = closestPointOnLine.add(offsetNow.mul(maxOffset / offsetLen));
        }
    }
    //
    NicelyAligned(longerSeg, del0, del1, midPointOfShorter, minDelLength, maxDelLen) {
        const eps = 0.001;
        const midDel = longerSeg.value(0.5).sub(midPointOfShorter);
        const midDelLen = midDel.length;
        if (del0.dot(midDel) < 0 || del1.dot(midDel) < 0) {
            return 1;
        }
        if (midDelLen < minDelLength - eps) {
            return 1;
        }
        if (midDelLen > maxDelLen + eps) {
            return -1;
        }
        return 0;
    }
    BaseLength(seg) {
        return seg.value(0).sub(seg.value(1)).lengthSquared;
    }
}
/* const */ EdgeNudger.SqueezeBound = 0.2;
//# sourceMappingURL=EdgeNudger.js.map