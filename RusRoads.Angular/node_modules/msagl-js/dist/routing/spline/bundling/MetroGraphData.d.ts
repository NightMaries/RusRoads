import { Port } from '../../../../src/layout/core/port';
import { GeomEdge, Point } from '../../..';
import { Polyline } from '../../../math/geometry';
import { PolylinePoint } from '../../../math/geometry/polylinePoint';
import { RectangleNode } from '../../../math/geometry/RTree/RectangleNode';
import { PointMap } from '../../../utils/PointMap';
import { BundlingSettings } from '../../BundlingSettings';
import { Cdt } from '../../ConstrainedDelaunayTriangulation/Cdt';
import { CdtIntersections } from './CdtIntersections';
import { Intersections } from './Intersections';
import { Metroline } from './MetroLine';
import { MetroNodeInfo } from './MetroNodeInfo';
import { Station } from './Station';
import { StationEdgeInfo } from './StationEdgeInfo';
import { TupleMap } from './tupleMap';
export declare class MetroGraphData {
    Stations: Array<Station>;
    edgeInfoDictionary: TupleMap<Station, Station, StationEdgeInfo>;
    ink: number;
    metrolines: Array<Metroline>;
    PointToStations: PointMap<Station>;
    regularEdges: GeomEdge[];
    looseIntersections: Intersections;
    tightIntersections: Intersections;
    cdtIntersections: CdtIntersections;
    EdgeLooseEnterable: Map<GeomEdge, Set<Polyline>>;
    EdgeTightEnterable: Map<GeomEdge, Set<Polyline>>;
    LoosePolylineOfPort: (p: Port) => Polyline;
    Cdt: Cdt;
    constructor(regularEdges: GeomEdge[], looseTree: RectangleNode<Polyline, Point>, tightTree: RectangleNode<Polyline, Point>, bundlingSettings: BundlingSettings, cdt: Cdt, edgeLooseEnterable: Map<GeomEdge, Set<Polyline>>, edgeTightEnterable: Map<GeomEdge, Set<Polyline>>, loosePolylineOfPort: (p: Port) => Polyline);
    get Ink(): number;
    get Edges(): GeomEdge[];
    VirtualStations(): Array<Station>;
    get Metrolines(): Array<Metroline>;
    get LooseTree(): RectangleNode<Polyline, Point>;
    get TightTree(): RectangleNode<Polyline, Point>;
    VirtualEdges(): IterableIterator<[Station, Station]>;
    RealEdgeCount(u: Station, v: Station): number;
    MetroNodeInfosOfNode(node: Station): Array<MetroNodeInfo>;
    GetIjInfo(u: Station, v: Station): StationEdgeInfo;
    MoveNode(node: Station, newPosition: Point): void;
    GetWidthSSN(u: Station, v: Station, edgeSeparation: number): number;
    GetWidthAN(metrolines: Array<Metroline>, edgeSeparation: number): number;
    Initialize(initTightTree: boolean): void;
    SimplifyRegularEdges(): void;
    SimplifyRegularEdge(edge: GeomEdge): void;
    InitializeStationData(): void;
    ProcessPolylinePoints(poly: Polyline): void;
    RegisterStation(pp: PolylinePoint, isRealNode: boolean): void;
    InitializeEdgeData(): void;
    InitEdgeData(geomEdge: GeomEdge, index: number): void;
    EdgeSourceAndTargetFunc(geomEdge: GeomEdge): () => [Polyline, Polyline];
    /**   Initialize graph comprised of stations and their neighbors */
    InitializeVirtualGraph(): void;
    GetUnorderedIjInfo(i: Station, j: Station): StationEdgeInfo;
    static closedeb(u: Station, v: Station): boolean;
    GetCreateOrderedIjInfo(i: Station, j: Station): StationEdgeInfo;
    InitializeEdgeNodeInfo(initTightTree: boolean): void;
    InitAllMetroNodeInfos(initTightTree: boolean): void;
    InitMetroNodeInfos(metroline: Metroline): void;
    InitNodeEnterableLoosePolylines(metroline: Metroline, regularEdge: GeomEdge): void;
    AddLooseEnterableForMetrolineStartEndPoints(metroline: Metroline): void;
    AddTightEnterableForMetrolineStartEndPoints(metroline: Metroline): void;
    cachedEnterableLooseForEnd: PointMap<Set<Polyline>>;
    AddLooseEnterableForEnd(point: Point): void;
    AddTightEnterableForEnd(point: Point): void;
    InitNodeEnterableTightPolylines(metroline: Metroline, regularEdge: GeomEdge): void;
    SortAllNeighbors(): void;
    SortNeighbors(station: Station): void;
    InitEdgeIjInfos(): void;
    InitializeCdtInfo(): void;
    PointIsAcceptableForEdge(metroline: Metroline, point: Point): boolean;
}
/**  computes orientation of three vectors with a common source
     (compare the polar angles of v1 and v2 with respect to v0)
      return -1 if the orientation is v0 v1 v2
               1 if the orientation is v0 v2 v1
               0  if v1 and v2 are collinear and codirectinal */
export declare function getOrientationOf3Vectors(v0: Point, v1: Point, v2: Point): number;
export declare function GreaterOrEqual(numberA: number, numberB: number): boolean;
