import { Point } from '../../..';
import { Polyline } from '../../../math/geometry';
import { PointPair } from '../../../math/geometry/pointPair';
import { PolylinePoint } from '../../../math/geometry/polylinePoint';
import { RTree } from '../../../math/geometry/RTree/RTree';
import { PointPairMap } from '../../../utils/pointPairMap';
import { PointSet } from '../../../utils/PointSet';
import { MetroGraphData } from './MetroGraphData';
import { Metroline } from './MetroLine';
export declare class PathFixer {
    metroGraphData: MetroGraphData;
    polylineAcceptsPoint: (m: Metroline, p: Point) => boolean;
    foundCrossings: PointSet;
    crossingsThatShouldBecomeHubs: PointSet;
    pointsToDelete: PointSet;
    constructor(metroGraphData: MetroGraphData, polylineAcceptsPoint: (m: Metroline, p: Point) => boolean);
    Vertices(): IterableIterator<PolylinePoint>;
    get Polylines(): Array<Polyline>;
    Edges(): Array<PointPair>;
    run(): boolean;
    FixPaths(): boolean;
    SortInsertedPoints(splittingPoints: PointPairMap<Array<Point>>): void;
    SortInsideSegment(edge: PointPair, list: Array<Point>): void;
    InsertPointsIntoPolylines(splittingPoints: PointPairMap<Array<Point>>): boolean;
    InsertPointsIntoPolyline(metroline: Metroline, splittingPoints: PointPairMap<Array<Point>>): boolean;
    InsertPointsOnPolypoint(pp: PolylinePoint, splittingPoints: PointPairMap<Array<Point>>, metroline: Metroline): boolean;
    RemoveSelfCycles(): boolean;
    static RemoveSelfCyclesFromPolyline(poly: Polyline): boolean;
    ReduceEdgeCrossings(): boolean;
    RemoveUnimportantCrossings(): boolean;
    RemoveUnimportantCrossingsFromPolyline(polyline: Polyline): boolean;
    IntersectTwoEdges(a: PointPair, b: PointPair, splittingPoints: PointPairMap<Array<Point>>, tree: RTree<Point, Point>): void;
    FindExistingVertexOrCreateNew(tree: RTree<Point, Point>, x: Point): Point;
    AddVertexToSplittingList(a: PointPair, splittingPoints: PointPairMap<Array<Point>>, intersectionPoint: Point): boolean;
}
