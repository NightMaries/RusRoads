import { Point, GeomEdge } from '../../..';
import { Polyline } from '../../../math/geometry';
import { RectangleNode } from '../../../math/geometry/RTree/RectangleNode';
import { BundlingSettings } from '../../BundlingSettings';
import { ClusterBoundaryPort } from '../../ClusterBoundaryPort';
import { Cdt } from '../../ConstrainedDelaunayTriangulation/Cdt';
import { CdtEdge } from '../../ConstrainedDelaunayTriangulation/CdtEdge';
import { VisibilityGraph } from '../../visibility/VisibilityGraph';
import { BundlingStatus } from './BundlingStatus';
import { Algorithm } from '../../../utils/algorithm';
import { SdShortestPath } from './SdShortestPath';
import { Port } from '../../../layout/core/port';
export declare class BundleRouter extends Algorithm {
    bundlingSettings: BundlingSettings;
    edgesToRoute: GeomEdge[];
    regularEdges: GeomEdge[];
    LoosePadding: number;
    static SuperLoosePaddingCoefficient: number;
    shortestPathRouter: SdShortestPath;
    TightHierarchy: RectangleNode<Polyline, Point>;
    LooseHierarchy: RectangleNode<Polyline, Point>;
    Status: BundlingStatus;
    VisibilityGraph: VisibilityGraph;
    loosePolylineOfPort: (a: Port) => Polyline;
    constructor(edgesToRoute: GeomEdge[], shortestPathRouter: SdShortestPath, visibilityGraph: VisibilityGraph, bundlingSettings: BundlingSettings, loosePadding: number, tightHierarchy: RectangleNode<Polyline, Point>, looseHierarchy: RectangleNode<Polyline, Point>, edgeLooseEnterable: Map<GeomEdge, Set<Polyline>>, edgeTightEnterable: Map<GeomEdge, Set<Polyline>>, loosePolylineOfPort: (a: Port) => Polyline);
    ThereAreOverlaps(hierarchy: RectangleNode<Polyline, Point>): boolean;
    run(): void;
    private OrderOptimizeNudgeEtc;
    FixChildParentEdges(): void;
    static CreateConstrainedDelaunayTriangulation(looseHierarchy: RectangleNode<Polyline, Point>): Cdt;
    static GetConstrainedDelaunayTriangulation(obstacles: Array<Polyline>): Cdt;
    FixLocationsForHookAnywherePorts(edges: GeomEdge[]): void;
    FigureOutHookLocation(poly: Polyline, otherEdgeEndPort: Port, edgeGeom: GeomEdge): Point;
    FigureOutHookLocationForClusterOtherPort(poly: Polyline, otherEdgeEndPort: ClusterBoundaryPort, edgeGeom: GeomEdge): Point;
    private FigureOutHookLocationForSimpleOtherPort;
    EdgeLooseEnterable: Map<GeomEdge, Set<Polyline>>;
    EdgeTightEnterable: Map<GeomEdge, Set<Polyline>>;
    RoutePathsWithSteinerDijkstra(): boolean;
    AnalyzeEdgeSeparation(): boolean;
    GetPathsOnCdtEdge(crossedEdges: Map<GeomEdge, Set<CdtEdge>>): Map<CdtEdge, Set<GeomEdge>>;
    CalculateMaxAllowedEdgeSeparation(pathsOnCdtEdge: Map<CdtEdge, Set<GeomEdge>>): number;
    EdgeSeparationIsOkMN(pathsOnCdtEdge: Map<CdtEdge, Set<GeomEdge>>, separation: number): boolean;
    EdgeSeparationIsOk(edge: CdtEdge, paths: Set<GeomEdge>, separation: number): boolean;
    RouteSelfEdges(): void;
    FixArrowheads(): void;
}
