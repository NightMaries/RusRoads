import { HashSet } from '@esfx/collections';
import { ICurve, Point } from '../../..';
import { PolylinePoint } from '../../../math/geometry/polylinePoint';
import { BundlingSettings } from '../../BundlingSettings';
import { BundleBase } from './BundleBase';
import { BundleInfo } from './BundleInfo';
import { GeneralMetroMapOrdering } from './GeneralMetroMapOrdering';
import { MetroGraphData } from './MetroGraphData';
import { Metroline } from './MetroLine';
export declare class BundleBasesCalculator {
    metroOrdering: GeneralMetroMapOrdering;
    metroGraphData: MetroGraphData;
    bundlingSettings: BundlingSettings;
    Bundles: Array<BundleInfo>;
    externalBases: Map<ICurve, Array<BundleBase>>;
    internalBases: Map<ICurve, Array<BundleBase>>;
    constructor(metroOrdering: GeneralMetroMapOrdering, metroGraphData: MetroGraphData, bundlingSettings: BundlingSettings);
    Run(): void;
    AllocateBundleBases(): void;
    SetBundleBaseNeighbors(): void;
    SortBundlesCounterClockwise(list: Array<BundleBase>): void;
    SetLeftRightBases(bases: Array<BundleBase>): void;
    CreateOrientedSegs(): void;
    CreateOrientedSegsOnLine(line: Metroline): void;
    CreateOrientedSegsOnLineVertex(line: Metroline, polyPoint: PolylinePoint): void;
    UpdateSourceAndTargetBases(): void;
    SetBasesRightLeftParamsToTheMiddles(): void;
    GetBaseMiddleParamInDirection(targetBase: BundleBase, sPos: Point, neighbPos: Point): number;
    SetRightLeftParamsFeasiblySymmetrically(): void;
    AdjustStartEndParamsToAvoidBaseOverlaps(): void;
    AdjustCurrentBundleWidthsOnCurve(bases: Array<BundleBase>): void;
    ShrinkBasesToMakeTwoConsecutiveNeighborsHappy(rBase: BundleBase, lBase: BundleBase): void;
    RegularCut(l1: number, r1: number, l2: number, r2: number, span1: number, span2: number): number;
    /** 1(-1) rotate point CCW(CW)*/
    static Deltas: number[][];
    static SeparationCoeff: number;
    static SqueezeCoeff: number;
    static CenterCoeff: number;
    static AssymetryCoeff: number;
    static MaxIterations: number;
    static MaxParameterChange: number;
    static MinParameterChange: number;
    static CostThreshold: number;
    static CostDeltaThreshold: number;
    fixedBundles: HashSet<BundleInfo>;
    RotateBundlesToDiminishCost(): void;
    stepsWithProgress: number;
    UpdateParameterChange(step: number, oldEnergy: number, newEnergy: number): number;
    RotateBundlesToDiminishCostOneIteration(parameterChange: number, t: {
        cost: number;
    }): boolean;
    OptimizeBundle(bundleInfo: BundleInfo, parameterChange: number, t: {
        cost: number;
    }): boolean;
    DeltaWithChangedAngles(rotationOfSourceRigthPoint: number, rotationOfSourceLeftPoint: number, rotationOfTargetRigthPoint: number, rotationOfTargetLeftPoint: number, bundleInfo: BundleInfo, bundleCost: number, parameterChange: number): number;
    CostBi(bundleInfo: BundleInfo): number;
    CostBN(bundleInfo: BundleInfo, limit: number): number;
    SqueezeCost(bundleInfo: BundleInfo): number;
    CenterCostBi(bundleInfo: BundleInfo): number;
    CenterCostBb(bundleBase: BundleBase): number;
    AssymetryCost(bundleInfo: BundleInfo): number;
    GetAssymetryCostForBase(bundleBase: BundleBase): number;
    GetAssymetryCostOnData(a: Point, tangentA: Point, b: Point, tangentB: Point, assymetryWeight: number): number;
    SeparationCost(bundleInfo: BundleInfo): number;
    SeparationCostForBundleBase(bBase: BundleBase): number;
    SeparationCostForAdjacentBundleBases(base0: BundleBase, base1: BundleBase): number;
    IntervalsOverlapLength(a: number, b: number, c: number, d: number, curve: ICurve): number;
    IntersectRegularIntervals(a: number, b: number, c: number, d: number): number;
    Cost(): number;
}
