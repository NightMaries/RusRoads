import { Point } from '../../..';
import { GeomEdge } from '../../..';
import { Polyline } from '../../../math/geometry';
import { PolylinePoint } from '../../../math/geometry/polylinePoint';
import { PointMap } from '../../../utils/PointMap';
import { PointSet } from '../../../utils/PointSet';
import { MetroGraphData } from './MetroGraphData';
export declare class FlipSwitcher {
    metroGraphData: MetroGraphData;
    polylineToEdgeGeom: Map<Polyline, GeomEdge>;
    pathsThroughPoints: PointMap<Set<PolylinePoint>>;
    interestingPoints: PointSet;
    numberOfReducedCrossings: number;
    get Polylines(): Array<Polyline>;
    constructor(metroGraphData: MetroGraphData);
    Run(): void;
    Init(): void;
    RegisterPolylinePointInPathsThrough(points: IterableIterator<PolylinePoint>): void;
    RegisterPolylinePointInPathsThroughP(pp: PolylinePoint): void;
    UnregisterPolylinePointsInPathsThrough(points: IterableIterator<PolylinePoint>): void;
    UnregisterPolylinePointInPathsThrough(pp: PolylinePoint): void;
    SwitchFlips(): void;
    ProcessPolyline(polyline: Polyline): Polyline;
    FillDepartedPolylinePoints(pp: PolylinePoint, departed: Map<Polyline, PolylinePoint>): void;
    ProcessFlip(flipStartPP: PolylinePoint, flipEndPP: PolylinePoint): boolean;
    FindPointsOnPolyline(polyline: Polyline, first: Point, last: Point): [PolylinePoint, PolylinePoint, boolean];
    PolylinePointsAreInForwardOrder(u: PolylinePoint, v: PolylinePoint): boolean;
    Next(p: PolylinePoint, forwardOrder: boolean): PolylinePoint;
    Prev(p: PolylinePoint, forwardOrder: boolean): PolylinePoint;
    FindRelationOnFirstPoint(aFirst: PolylinePoint, bFirst: PolylinePoint, forwardOrderA: boolean, forwardOrderB: boolean): number;
    FindRelationOnLastPoint(aLast: PolylinePoint, bLast: PolylinePoint, forwardOrderA: boolean, forwardOrderB: boolean): number;
    PolylinesIntersect(a0: PolylinePoint, b0: PolylinePoint, a1: PolylinePoint, b1: PolylinePoint, forwardOrderA: boolean, forwardOrderB: boolean): number;
    Swap(aFirst: PolylinePoint, bFirst: PolylinePoint, aLast: PolylinePoint, bLast: PolylinePoint, forwardOrderA: boolean, forwardOrderB: boolean): void;
    ChangePolylineSegment(aFirst: PolylinePoint, aLast: PolylinePoint, forwardOrderA: boolean, intermediateBPoints: Array<PolylinePoint>): void;
    GetRangeOnPolyline(start: PolylinePoint, end: PolylinePoint, forwardOrder: boolean): Array<PolylinePoint>;
    IsNeighborOnTheSamePolyline(a: PolylinePoint, b: PolylinePoint): boolean;
    RegisterInterestingPoint(p: Point): void;
    GetChangedHubs(): PointSet;
    NumberOfReducedCrossings(): number;
    PolylineIsOK(poly: Polyline): boolean;
}
