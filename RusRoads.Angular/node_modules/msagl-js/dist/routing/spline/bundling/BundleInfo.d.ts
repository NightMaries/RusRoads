import { LineSegment, Point, Polyline } from '../../../math/geometry';
import { RectangleNode } from '../../../math/geometry/RTree/RectangleNode';
import { BundleBase } from './BundleBase';
export declare class BundleInfo {
    static FeasibleWidthEpsilon: number;
    SourceBase: BundleBase;
    TargetBase: BundleBase;
    obstaclesToIgnore: Set<Polyline>;
    EdgeSeparation: number;
    HalfWidthArray: number[];
    longEnoughSideLength: number;
    tightObstaclesInTheBoundingBox: Array<Polyline>;
    TotalRequiredWidth: number;
    constructor(sourceBase: BundleBase, targetBase: BundleBase, obstaclesToIgnore: Set<Polyline>, edgeSeparation: number, halfWidthArray: number[]);
    SetParamsFeasiblySymmetrically(tightTree: RectangleNode<Polyline, Point>): void;
    CalculateTightObstaclesForBundle(tightTree: RectangleNode<Polyline, Point>, obstaclesToIgnore: Set<Polyline>): void;
    SetEndParamsSymmetrically(): void;
    mkNameFromLRST(): string;
    SetRLParamsIfWidthIsFeasible(perp: Point, a: Point, b: Point): boolean;
    SetRLParamsIfWidthIsFeasible_(perpL: Point, perpR: Point, a: Point, b: Point): boolean;
    SetInitialMidParams(): void;
    mkNameFromST(): string;
    TrimSegWithBoundaryCurves(ls: LineSegment, s: {
        par: number;
    }, t: {
        par: number;
    }): LineSegment;
    RotateBy(rotationOfSourceRightPoint: number, rotationOfSourceLeftPoint: number, rotationOfTargetRightPoint: number, rotationOfTargetLeftPoint: number, parameterChange: number): void;
    UpdateSourceAndTargetBases(sourceChanged: boolean, targetChanged: boolean): void;
    private UpdateTangentsOnBases;
    UpdatePointsOnBundleBase(bb: BundleBase): void;
    RotationIsLegal(rotationOfSourceRightPoint: number, rotationOfSourceLeftPoint: number, rotationOfTargetRightPoint: number, rotationOfTargetLeftPoint: number, parameterChange: number): boolean;
    LineIsLegal(a: Point, b: Point): boolean;
}
