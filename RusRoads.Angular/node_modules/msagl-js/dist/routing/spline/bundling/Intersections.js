//  Check intersections between hubs and obstacles with kd-tree
import { Point } from '../../..';
import { Polyline, PointLocation, Curve } from '../../../math/geometry';
import { uniteSets } from '../../../utils/setOperations';
export class Intersections {
    constructor(metroGraphData, bundlingSettings, obstacleTree, obstaclesToIgnore) {
        this.metroGraphData = metroGraphData;
        this.obstaclesToIgnoreLambda = obstaclesToIgnore;
        this.bundlingSettings = bundlingSettings;
        this.obstacleTree = obstacleTree;
    }
    ObstaclesToIgnoreForBundle(u, v) {
        if (u != null && v != null) {
            return uniteSets(this.obstaclesToIgnoreLambda(u), this.obstaclesToIgnoreLambda(v));
        }
        if (u == null && v == null) {
            return new Set();
        }
        if (u != null) {
            return this.obstaclesToIgnoreLambda(u);
        }
        else {
            return this.obstaclesToIgnoreLambda(v);
        }
    }
    HubAvoidsObstaclesSPNBA(node, center, upperBound, t) {
        const md = { minimalDistance: upperBound };
        return Intersections.IntersectCircleWithTree(this.obstacleTree, center, upperBound, this.obstaclesToIgnoreLambda(node), t.touchedObstacles, md);
    }
    HubAvoidsObstaclesPNS__(center, upperBound, obstaclesToIgnore) {
        const t = { touchedObstacles: Array() };
        const md = { minimalDistance: 0 };
        return this.HubAvoidsObstaclesPNSTT(center, upperBound, obstaclesToIgnore, t, md);
    }
    GetMinimalDistanceToObstacles(node, nodePosition, upperBound) {
        const touchedObstacles = new Array();
        const t = { minimalDistance: upperBound };
        if (!Intersections.IntersectCircleWithTree(this.obstacleTree, nodePosition, upperBound, this.obstaclesToIgnoreLambda(node), touchedObstacles, t)) {
            return 0;
        }
        return t.minimalDistance;
    }
    HubAvoidsObstaclesPNSTT(center, upperBound, obstaclesToIgnore, t, m) {
        t.touchedObstacles = new Array();
        m.minimalDistance = upperBound;
        return Intersections.IntersectCircleWithTree(this.obstacleTree, center, upperBound, obstaclesToIgnore, t.touchedObstacles, m);
    }
    //  Computes the intersection between the hub and obstacles
    // Returns false iff the center is inside of an obstacle, which is not ignored
    static IntersectCircleWithTree(node, center, radius, obstaclesToIgnore, touchedObstacles, t) {
        if (!node.irect.contains_point_radius(center, radius)) {
            return true;
        }
        if (node.UserData == null) {
            let res = Intersections.IntersectCircleWithTree(node.Left, center, radius, obstaclesToIgnore, touchedObstacles, t);
            if (!res) {
                return false;
            }
            res = Intersections.IntersectCircleWithTree(node.Right, center, radius, obstaclesToIgnore, touchedObstacles, t);
            if (!res) {
                return false;
            }
        }
        else {
            const obstacle = node.UserData;
            if (obstaclesToIgnore.has(obstacle)) {
                return true;
            }
            const pl = Curve.PointRelativeToCurveLocation(center, obstacle);
            if (pl != PointLocation.Outside) {
                Intersections.containingPoly = obstacle;
                return false;
            }
            const touchPoint = obstacle.value(obstacle.closestParameter(center));
            const dist = touchPoint.sub(center).length;
            if (dist <= radius) {
                touchedObstacles.push([obstacle, touchPoint]);
            }
            t.minimalDistance = Math.min(dist, t.minimalDistance);
        }
        return true;
    }
    static Create4gon(apex, baseCenter, width1, width2) {
        let norm = baseCenter.sub(apex).normalize();
        norm = new Point(norm.y, norm.x * -1);
        return Polyline.mkFromPoints([
            apex.add(norm.mul(width1 / 2)),
            apex.sub(norm.mul(width1 / 2)),
            baseCenter.sub(norm.mul(width2 / 2)),
            baseCenter.add(norm.mul(width2 / 2)),
        ]);
    }
}
//#if TEST_MSAGL && TEST_MSAGL
// check the validness of the drawing:
//     // 1. hubs are not inside loose obstacles
//     // 2. bundles do not cross loose obstacles
//     // <
//      bool HubPositionsAreOK() {
//         //check polylines
//         foreach(var line of metroGraphData.Metrolines) {
//             var poly = line.Polyline;
//             foreach(var p of poly.PolylinePoints)
//             Assert.assert(metroGraphData.PointToStations.ContainsKey(p.point));
//         }
//         foreach(var station of metroGraphData.Stations) {
//             if (!station.IsRealNode && !HubAvoidsObstacles(station.Position, 0, obstaclesToIgnore(station))) {
//                 if (LayoutAlgorithmSettings.ShowDebugCurvesEnumeration != null) {
//                     HubDebugger.ShowHubs(metroGraphData, bundlingSettings, station);
//                     ShowStationWithObstaclesToIgnore(station, obstacleTree.AllHitItems(station.Position));
//                 }
//                 return false;
//             }
//             //bundles
//             foreach(var adj of station.Neighbors) {
//                 if (Point.closeDistEps(adj.Position, station.Position))
//                     return false;
//                 if (!EdgeIsLegal(station, adj, station.Position, adj.Position)) {
//                     if (LayoutAlgorithmSettings.ShowDebugCurvesEnumeration != null) {
//                         //debug visualization
//                         var l = new Array<DebugCurve>();
//                         //foreach (var st of metroGraphData.Stations) {
//                         //    l.Add(new DebugCurve(100, 0.5, "grey", st.BoundaryCurve));
//                         //}
//                         foreach(var poly of obstaclesToIgnore(station)) {
//                             l.Add(new DebugCurve(100, 5, "green", poly));
//                         }
//                         foreach(var obstacle of obstacleTree.GetAllLeaves()) {
//                             l.Add(new DebugCurve(100, 1, "red", obstacle));
//                         }
//                         l.Add(new DebugCurve(1, "blue", station.BoundaryCurve));
//                         l.Add(new DebugCurve(1, "blue", adj.BoundaryCurve));
//                         l.Add(new DebugCurve(1, "blue", new LineSegment(adj.Position, adj.Neighbors.First().Position)));
//                         l.Add(new DebugCurve(1, "blue", new LineSegment(station.Position, adj.Position)));
//                         LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
//                         //end debug visualization
//                         return false;
//                     }
//                 }
//             }
//         }
//         return true;
//     }
//     void ShowStationWithObstaclesToIgnore(Station station, Array < Polyline > allHitItems) {
//         var l = new Array<DebugCurve>();
//         foreach(var poly of allHitItems) {
//             l.Add(new DebugCurve(100, 0.5, "brown", poly));
//         }
//         if (obstaclesToIgnore(station) != null)
//             foreach(var poly of obstaclesToIgnore(station))
//         l.Add(new DebugCurve(100, 1, "red", poly));
//         foreach(var obstacle of obstacleTree.GetAllLeaves())
//         l.Add(new DebugCurve(50, 0.1, "green", obstacle));
//         l.Add(new DebugCurve(0.1, "blue", new Ellipse(1, 1, station.Position)));
//         LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
//     }
//     // edge doesn't cross obstacles
//     // NOTE: use method in CdtIntersection insetad!
//     // <
//     bool EdgeIsLegal(Station stationA, Station stationB, Point a, Point b) {
//         var crossings = InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolyline(new LineSegment(a, b), obstacleTree);
//         Set < Polyline > obstaclesToIgnoreForBundle = ObstaclesToIgnoreForBundle(stationA, stationB);
//         if (crossings.Count < 0) {
//             var l = new Array<DebugCurve>();
//             var crossingSet = new Set<ICurve>(crossings.Select(ii => ii.Segment1));
//             l.AddRange(crossingSet.Select(p => new DebugCurve(100, 1, "red", p)));
//             l.AddRange(obstaclesToIgnoreForBundle.Select(p => new DebugCurve(100, 0.5, "green", p)));
//             LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
//         }
//         return crossings.All(intersectionInfo => obstaclesToIgnoreForBundle.Contains((Polyline)intersectionInfo.Segment1));
//     }
// #endif
// }
//# sourceMappingURL=Intersections.js.map