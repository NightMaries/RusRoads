import { Point } from '../../..';
import { PointPair } from '../../../math/geometry/pointPair';
import { PolylinePoint } from '../../../math/geometry/polylinePoint';
import { PointPairMap } from '../../../utils/pointPairMap';
import { Metroline } from './MetroLine';
import { PointPairOrder } from './PointPairOrder';
import { Station } from './Station';
export declare class GeneralMetroMapOrdering {
    Metrolines: Array<Metroline>;
    bundles: PointPairMap<PointPairOrder>;
    constructor(Metrolines: Array<Metroline>);
    GetOrder(u: Station, v: Station): IterableIterator<Metroline>;
    /**   Get the index of line on the edge (u->v) and node u */
    GetLineIndexInOrder(u: Station, v: Station, ml: Metroline): number;
    /**   Do the main job */
    BuildOrder(): void;
    /**   Build an order for edge (u->v) */
    BuildOrderPP(pair: PointPair, order: PointPairOrder): void;
    /**   Compare two lines on station u with respect to edge (u->v) */
    CompareLines(ml0: Metroline, ml1: Metroline, u: Point, v: Point): number;
    CompareOnFixedOrder(edge: PointPair, ml0: Metroline, ml1: Metroline, reverse: boolean): number;
    /** Fills Next and Prev functions according to the direction of the metroline */
    FindStationOnLine(u: Point, v: Point, ml: Metroline, t: {
        polyPoint: PolylinePoint;
        next: (a: PolylinePoint) => PolylinePoint;
        prev: (a: PolylinePoint) => PolylinePoint;
    }): void;
    /**  computes orientation of three vectors with a common source
       (compare the polar angles of v1 and v2 with respect to v0),
        return -1 if the orientation is v0 v1 v2,
                 1 if the orientation is v0 v2 v1,
                 0  if v1 and v2 are collinear and codirectinal, TODO: seems fishy */
    static IsLeft(v0: Point, v1: Point, v2: Point): number;
}
