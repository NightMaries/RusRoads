import { ICurve, Point } from '../../..';
import { BundleInfo } from './BundleInfo';
import { OrientedHubSegment } from './OrientedHubSegment';
export declare class BundleBase {
    OutgoingBundleInfo: BundleInfo;
    IncomingBundleInfo: BundleInfo;
    private points;
    tangents: Point[];
    OrientedHubSegments: OrientedHubSegment[];
    Curve: ICurve;
    IsParent: boolean;
    BelongsToRealNode: boolean;
    Position: Point;
    get Count(): number;
    constructor(count: number, boundaryCurve: ICurve, position: Point, belongsToRealNode: boolean);
    get CurveCenter(): Point;
    get OppositeBase(): BundleBase;
    get length(): number;
    get Points(): Point[];
    get Tangents(): Point[];
    initialMidParameter: number;
    get InitialMidParameter(): number;
    set InitialMidParameter(value: number);
    InitialMidPoint: Point;
    parRight: number;
    get ParRight(): number;
    set ParRight(value: number);
    parLeft: number;
    get ParLeft(): number;
    set ParLeft(value: number);
    get ParMid(): number;
    RightPoint: Point;
    LeftPoint: Point;
    get MidPoint(): Point;
    Prev: BundleBase;
    Next: BundleBase;
    ParameterSpan: number;
    get Span(): number;
    SpanBetweenTwoPoints(right: number, left: number): number;
    RotateLeftPoint(rotationOfSourceLeftPoint: number, parameterChange: number): Point;
    RotateRigthPoint(rotationOfSourceRightPoint: number, parameterChange: number): Point;
    RotatePoint(rotation: number, t: number, parameterChange: number): Point;
    AdjustParam(t: number): number;
    RotateBy(rotationOfRightPoint: number, rotationOfLeftPoint: number, parameterChange: number): void;
    Intersect(other: BundleBase): boolean;
    IntersectNNNB(lParRight: number, lParLeft: number, rParRight: number, rParLeft: number): boolean;
    RelativeOrderOfBasesIsPreserved(rotationOfRightPoint: number, rotationOfLeftPoint: number, parameterChange: number): boolean;
}
