export class CdtSite {
    constructor(isolatedSite) {
        //  Object to which this site refers to.
        this.Owner = null;
        this.InEdges = new Array();
        this.point = isolatedSite;
    }
    static mkSO(isolatedSite, owner) {
        const s = new CdtSite(isolatedSite);
        s.Owner = owner;
        return s;
    }
    AddEdgeToSite(edge) {
        if (this.Edges == null) {
            this.Edges = new Array();
        }
        this.Edges.push(edge);
    }
    //  #if TEST_MSAGL && TEST_MSAGL
    //          // Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
    //          // A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
    //          // <filterpriority>2</filterpriority>
    //          public override string ToString()
    //          {
    //              return Point.ToString();
    //          }
    //  #endif
    EdgeBetweenUpperSiteAndLowerSite(b) {
        /*Assert.assert(Cdt.AboveCC(this, b) > 0)*/
        if (this.Edges != null) {
            for (const edge of this.Edges) {
                if (edge.lowerSite == b) {
                    return edge;
                }
            }
        }
        return null;
    }
    AddInEdge(e) {
        if (this.InEdges == null) {
            this.InEdges = new Array();
        }
        this.InEdges.push(e);
    }
    *Triangles() {
        // this function might not work correctly if InEdges are not set
        let edge;
        if (this.Edges != null && this.Edges.length > 0)
            edge = this.Edges[0];
        else if (this.InEdges != null && this.InEdges.length > 0)
            edge = this.InEdges[0];
        else
            return;
        //going counterclockwise around the site
        let e = edge;
        do {
            const t = e.upperSite == this ? e.CcwTriangle : e.CwTriangle;
            if (t == null) {
                e = null;
                break;
            }
            yield t;
            e = t.TriEdges.getItem(t.TriEdges.index(e) + 2);
        } while (e != edge); //full circle
        if (e != edge) {
            //we have not done the full circle, starting again with edge but now going clockwise around the site
            e = edge;
            do {
                const t = e.upperSite == this ? e.CwTriangle : e.CcwTriangle;
                if (t == null) {
                    break;
                }
                yield t;
                e = t.TriEdges.getItem(t.TriEdges.index(e) + 1);
            } while (true); // we will hit a null triangle for the convex hull border edge
        }
    }
    toString() {
        return this.point.toString();
    }
}
//# sourceMappingURL=CdtSite.js.map