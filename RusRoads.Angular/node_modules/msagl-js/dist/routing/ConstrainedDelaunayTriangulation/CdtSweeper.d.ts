import { DebugCurve } from '../../math/geometry/debugCurve';
import { ICurve } from '../../math/geometry/icurve';
import { RBNode } from '../../structs/RBTree/rbNode';
import { RBTree } from '../../structs/RBTree/rbTree';
import { Algorithm } from '../../utils/algorithm';
import { CdtEdge } from './CdtEdge';
import { CdtFrontElement } from './CdtFrontElement';
import { CdtSite } from './CdtSite';
import { CdtTriangle } from './CdtTriangle';
import { PerimeterEdge } from './PerimeterEdge';
export declare class CdtSweeper extends Algorithm {
    front: RBTree<CdtFrontElement>;
    triangles: Set<CdtTriangle>;
    listOfSites: Array<CdtSite>;
    p_2: CdtSite;
    createEdgeDelegate: (a: CdtSite, b: CdtSite) => CdtEdge;
    p_1: CdtSite;
    constructor(listOfSites: Array<CdtSite>, p_1: CdtSite, p_2: CdtSite, createEdgeDelegate: (a: CdtSite, b: CdtSite) => CdtEdge);
    run(): void;
    FinalizeTriangulation(): void;
    MakePerimeterConvex(): void;
    FindConcaveEdge(firstPerimeterEdge: PerimeterEdge): PerimeterEdge;
    static FindPivot(firstPerimeterEdge: PerimeterEdge): PerimeterEdge;
    FindFirsePerimeterEdge(): CdtEdge;
    CreateDoubleLinkedListOfPerimeter(): PerimeterEdge;
    static FindNextEdgeOnPerimeter(e: CdtEdge): CdtEdge;
    static CreatePerimeterElementFromEdge(edge: CdtEdge): PerimeterEdge;
    RemoveP1AndP2Triangles(): void;
    static RemoveTriangleWithEdges(cdtTriangles: Set<CdtTriangle>, t: CdtTriangle): void;
    static RemoveTriangleButLeaveEdges(cdtTriangles: Set<CdtTriangle>, t: CdtTriangle): void;
    ProcessSite(site: CdtSite): void;
    EdgeEvent(edge: CdtEdge): void;
    static EdgeIsProcessed(edge: CdtEdge): boolean;
    ShowFrontWithSite(site: CdtSite, redCurves?: ICurve[]): void;
    Show(fn: string): void;
    static ShowCdt(cdtTriangles: CdtTriangle[], cdtFrontElements: RBTree<CdtFrontElement>, redCurves: Array<ICurve>, blueCurves: Array<ICurve>, dc: DebugCurve[], fn: string): void;
    static GetDebugCurveOfCdtEdge(e: CdtEdge): DebugCurve;
    PointEvent(pi: CdtSite): void;
    LeftCase(pi: CdtSite, hittedFrontElementNode: RBNode<CdtFrontElement>, t: {
        rightSite: CdtSite;
    }): CdtSite;
    MiddleCase(pi: CdtSite, hittedFrontElementNode: RBNode<CdtFrontElement>, t: {
        rightSite: CdtSite;
    }): CdtSite;
    TriangulateEmptySpaceToTheLeft(leftLegNode: RBNode<CdtFrontElement>): void;
    ShortcutTwoListElements(a: PerimeterEdge): PerimeterEdge;
    ShortcutTwoFrontElements(aNode: RBNode<CdtFrontElement>, bNode: RBNode<CdtFrontElement>): RBNode<CdtFrontElement>;
    TryTriangulateBasinToTheLeft(leftLegNode: RBNode<CdtFrontElement>): void;
    static DropsSharpEnoughToTheLeft(frontElement: CdtFrontElement): boolean;
    InsertSiteIntoFront(leftSite: CdtSite, pi: CdtSite, rightSite: CdtSite): RBNode<CdtFrontElement>;
    TriangulateEmptySpaceToTheRight(piNode: RBNode<CdtFrontElement>): void;
    TryTriangulateBasinToTheRight(piNode: RBNode<CdtFrontElement>): void;
    static DropsSharpEnoughToTheRight(frontElement: CdtFrontElement): boolean;
    static FindNodeInFrontBySite(cdtFrontElements: RBTree<CdtFrontElement>, piSite: CdtSite): RBNode<CdtFrontElement>;
    InsertAndLegalizeTriangle(pi: CdtSite, frontElement: CdtFrontElement): void;
    LegalizeEdge(pi: CdtSite, edge: CdtEdge): void;
    LegalizeEdgeForOtherCwTriangle(pi: CdtSite, edge: CdtEdge): void;
    LegalizeEdgeForOtherCcwTriangle(pi: CdtSite, edge: CdtEdge): void;
    ProjectToFront(site: CdtSite): RBNode<CdtFrontElement>;
}
export declare function InCircle(d: CdtSite, a: CdtSite, b: CdtSite, c: CdtSite): boolean;
