import { Point } from '../../math/geometry/point';
import { Polyline } from '../../math/geometry/polyline';
import { PointMap } from '../../utils/PointMap';
import { Algorithm } from './../../utils/algorithm';
import { CdtEdge } from './CdtEdge';
import { CdtSite } from './CdtSite';
import { CdtTriangle } from './CdtTriangle';
import { SymmetricTuple } from './../../structs/SymmetricTuple';
import { CdtSweeper } from './CdtSweeper';
import { RectangleNode } from '../../math/geometry/RTree/RectangleNode';
declare type SymmetricSegment = SymmetricTuple<Point>;
export declare class Cdt extends Algorithm {
    isolatedSitesWithObject: Array<[Point, unknown]>;
    isolatedSites: Point[];
    obstacles: Polyline[];
    isolatedSegments: Array<SymmetricSegment>;
    P1: CdtSite;
    P2: CdtSite;
    sweeper: CdtSweeper;
    PointsToSites: PointMap<CdtSite>;
    allInputSites: Array<CdtSite>;
    constructor(isolatedSites: Point[], obstacles: Array<Polyline>, isolatedSegments: Array<SymmetricSegment>);
    static constructor_(isolatedSitesWithObj: Array<[Point, unknown]>): Cdt;
    FillAllInputSites(): void;
    AddSite(point: Point, relatedObject: unknown): CdtSite;
    AddP1AndP2(): void;
    AddPolylineToAllInputSites(poly: Polyline): void;
    AddConstrainedEdge(a: Point, b: Point, poly: Polyline): void;
    static GetOrCreateEdge(a: CdtSite, b: CdtSite): CdtEdge;
    static CreateEdgeOnOrderedCouple(upperPoint: CdtSite, lowerPoint: CdtSite): CdtEdge;
    GetTriangles(): Set<CdtTriangle>;
    run(): void;
    SweepAndFinalize(): void;
    Initialization(): void;
    static OnComparison(a: CdtSite, b: CdtSite): number;
    static AbovePP(a: Point, b: Point): number;
    static AboveCC(a: CdtSite, b: CdtSite): number;
    RestoreEdgeCapacities(): void;
    SetInEdges(): void;
    FindSite(point: Point): CdtSite;
    static PointIsInsideOfTriangle(point: Point, t: CdtTriangle): boolean;
    cdtTree: RectangleNode<CdtTriangle, Point>;
    GetCdtTree(): RectangleNode<CdtTriangle, Point>;
    EdgeIsCorrect(edge: CdtEdge): boolean;
}
export {};
