import { Point } from '../../math/geometry/point';
import { RBNode } from '../../structs/RBTree/rbNode';
import { ScanDirection } from './ScanDirection';
import { ScanSegment } from './ScanSegment';
export declare class ScanSegmentTree {
    ScanDirection: ScanDirection;
    private segmentTree;
    lookupSegment: ScanSegment;
    findIntersectorPred: (ss: ScanSegment) => boolean;
    findPointPred: (ss: ScanSegment) => boolean;
    constructor(scanDir: ScanDirection);
    get Segments(): IterableIterator<ScanSegment>;
    InsertUnique(seg: ScanSegment): RBNode<ScanSegment>;
    AssertValidSegmentForInsertion(seg: ScanSegment): void;
    Remove(seg: ScanSegment): void;
    Find(start: Point, end: Point): ScanSegment;
    FindLowestIntersector(start: Point, end: Point): ScanSegment;
    FindLowestIntersectorNode(start: Point, end: Point): RBNode<ScanSegment>;
    FindHighestIntersector(start: Point, end: Point): ScanSegment;
    CompareIntersector(seg: ScanSegment): boolean;
    FindSegmentContainingPoint(location: Point, allowUnfound: boolean): ScanSegment;
    FindSegmentOverlappingPoints(start: Point, end: Point, allowUnfound: boolean): ScanSegment;
    CompareToPoint(treeSeg: ScanSegment): boolean;
    MergeAndRemoveNextNode(currentSegment: ScanSegment, nextSegNode: RBNode<ScanSegment>): RBNode<ScanSegment>;
    MergeSegments(): void;
    Compare(first: ScanSegment, second: ScanSegment): number;
}
