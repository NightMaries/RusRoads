import { Point, Rectangle, GeomConstants } from '../../math/geometry';
import { ObstaclePortEntrance } from './ObstaclePortEntrance';
export class ObstaclePort {
    constructor(port, obstacle) {
        this.HasCollinearEntrances = false;
        this.VisibilityRectangle = Rectangle.mkEmpty();
        this.Port = port;
        this.Obstacle = obstacle;
        this.PortEntrances = new Array();
        this.Location = GeomConstants.RoundPoint(this.Port.Location);
    }
    CreatePortEntrance(unpaddedBorderIntersect, outDir, obstacleTree) {
        const entrance = new ObstaclePortEntrance(this, unpaddedBorderIntersect, outDir, obstacleTree);
        this.PortEntrances.push(entrance);
        this.VisibilityRectangle.add(entrance.MaxVisibilitySegment.end);
        this.HasCollinearEntrances = this.HasCollinearEntrances || entrance.IsCollinearWithPort;
    }
    ClearVisibility() {
        //  Most of the retained PortEntrance stuff is about precalculated visibility.
        this.PortEntrances = [];
    }
    AddToGraph(transUtil, routeToCenter) {
        //  We use only border vertices if !routeToCenter.
        if (routeToCenter) {
            this.CenterVertex = transUtil.FindOrAddVertex(this.Location);
        }
    }
    RemoveFromGraph() {
        this.CenterVertex = null;
    }
    //  PortManager will recreate the Port if it detects this (this.Location has already been rounded).
    get LocationHasChanged() {
        return !Point.closeDistEps(this.Location, GeomConstants.RoundPoint(this.Port.Location));
    }
    ///  The curve associated with the port.
    get PortCurve() {
        return this.Port.Curve;
    }
    ///  The (unrounded) location of the port.
    get PortLocation() {
        return this.Port.Location;
    }
    ///  <returns></returns>
    toString() {
        return this.Port + this.Obstacle.toString();
    }
}
//# sourceMappingURL=ObstaclePort.js.map