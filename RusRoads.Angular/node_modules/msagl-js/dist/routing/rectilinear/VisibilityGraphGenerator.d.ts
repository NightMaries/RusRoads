import { Direction } from '../../math/geometry/direction';
import { Point } from '../../math/geometry/point';
import { Polyline } from '../../math/geometry/polyline';
import { PolylinePoint } from '../../math/geometry/polylinePoint';
import { RBNode } from '../../structs/RBTree/rbNode';
import { SweepEvent } from '../spline/coneSpanner/SweepEvent';
import { VisibilityGraph } from '../visibility/VisibilityGraph';
import { VisibilityVertex } from '../visibility/VisibilityVertex';
import { BasicObstacleSide } from './BasicObstacleSide';
import { BasicReflectionEvent } from './basicReflectionEvent';
import { BasicVertexEvent } from './BasicVertexEvent';
import { EventQueue } from './EventQueue';
import { GroupBoundaryCrossingMap } from './GroupBoundaryCrossingMap';
import { HighReflectionEvent } from './HighReflectionEvent';
import { LookaheadScan } from './LookaheadScan';
import { CloseVertexEvent, HighBendVertexEvent, LowBendVertexEvent } from './MiscVertexEvents';
import { LowReflectionEvent } from './LowReflectionEvent';
import { NeighborSides } from './NeighborSides';
import { Obstacle } from './obstacle';
import { ObstacleTree } from './ObstacleTree';
import { OpenVertexEvent } from './OpenVertexEvent';
import { RectilinearScanLine } from './RectilinearScanLine';
import { ScanDirection } from './ScanDirection';
import { ScanSegmentTree } from './ScanSegmentTree';
export declare abstract class VisibilityGraphGenerator {
    protected ScanDirection: ScanDirection;
    VisibilityGraph: VisibilityGraph;
    constructor(wantReflections: boolean);
    protected eventQueue: EventQueue;
    HorizontalScanSegments: ScanSegmentTree;
    VerticalScanSegments: ScanSegmentTree;
    protected get ParallelScanSegments(): ScanSegmentTree;
    protected get PerpendicularScanSegments(): ScanSegmentTree;
    lookaheadScan: LookaheadScan;
    private wantReflections;
    ObstacleTree: ObstacleTree;
    protected scanLine: RectilinearScanLine;
    static SentinelOffset: number;
    protected CurrentGroupBoundaryCrossingMap: GroupBoundaryCrossingMap;
    protected LowNeighborSides: NeighborSides;
    protected HighNeighborSides: NeighborSides;
    static NewVisibilityGraph(): VisibilityGraph;
    GenerateVisibilityGraph(): void;
    static ScanLineIntersectSidePBS(site: Point, side: BasicObstacleSide, scanDir: ScanDirection): Point;
    GetOpenVertex(poly: Polyline): PolylinePoint;
    TraversePolylineForEvents(polyPoint: PolylinePoint): PolylinePoint;
    InitializeEventQueue(scanDir: ScanDirection): void;
    EnqueueBottomVertexEvents(): void;
    IsFlat(side: BasicObstacleSide): boolean;
    IsPerpendicular(side: BasicObstacleSide): boolean;
    protected ScanLineIntersectSide(site: Point, side: BasicObstacleSide): Point;
    protected SideReflectsUpward(side: BasicObstacleSide): boolean;
    SideReflectsDownward(side: BasicObstacleSide): boolean;
    protected StoreLookaheadSite(initialObstacle: Obstacle, reflectingSide: BasicObstacleSide, reflectionSite: Point, wantExtreme: boolean): void;
    LoadReflectionEvents(sideToQueue: BasicObstacleSide): void;
    protected LoadReflectionEventsBB(sideToQueue: BasicObstacleSide, sideWithRange: BasicObstacleSide): void;
    AddPerpendicularReflectionSegment(currentEvent: BasicReflectionEvent, eventSide: BasicObstacleSide, nborSide: BasicObstacleSide): boolean;
    protected abstract InsertPerpendicularReflectionSegment(start: Point, end: Point): boolean;
    private AddParallelReflectionSegment;
    abstract InsertParallelReflectionSegment(start: Point, end: Point, eventObstacle: Obstacle, lowNborSide: BasicObstacleSide, highNborSide: BasicObstacleSide, action: BasicReflectionEvent): boolean;
    AddReflectionEvent(previousSite: BasicReflectionEvent, side: BasicObstacleSide, site: Point): void;
    AddSideToScanLine(side: BasicObstacleSide, scanPos: Point): RBNode<BasicObstacleSide>;
    RemoveSideFromScanLine(sideNode: RBNode<BasicObstacleSide>, scanPos: Point): void;
    PointCompare(lhs: Point, rhs: Point): number;
    Clear(): void;
    private ProcessEvents;
    ProcessCustomEvent(evt: SweepEvent): void;
    protected ScanLineCrossesObstacle(eventSite: Point, obstacle: Obstacle): boolean;
    FindInitialNeighborSides(sideNode: RBNode<BasicObstacleSide>, t: {
        lowNborSideNode: RBNode<BasicObstacleSide>;
        highNborSideNode: RBNode<BasicObstacleSide>;
    }): void;
    protected FindNeighborsBRR(vertexEvent: BasicVertexEvent, lowSideNode: RBNode<BasicObstacleSide>, highSideNode: RBNode<BasicObstacleSide>): void;
    protected FindNeighbors(vertexEvent: BasicVertexEvent, sideNode: RBNode<BasicObstacleSide>, neighborSides: NeighborSides): void;
    SkipToNeighbor(nborSearchDir: Direction, side: BasicObstacleSide, sideReferencePoint: Point, nborNode: RBNode<BasicObstacleSide>, neighborSides: NeighborSides): void;
    private ProcessGroupSideEncounteredOnTraversalToNeighbor;
    FindNeighborsAndProcessVertexEvent(lowSideNode: RBNode<BasicObstacleSide>, highSideNode: RBNode<BasicObstacleSide>, vertexEvent: BasicVertexEvent): void;
    protected abstract ProcessVertexEvent(lowSideNode: RBNode<BasicObstacleSide>, highSideNode: RBNode<BasicObstacleSide>, vertexEvent: BasicVertexEvent): void;
    ProcessEventO(openVertEvent: OpenVertexEvent): void;
    ProcessEventLB(lowVertEvent: LowBendVertexEvent): void;
    EnqueueLowBendVertexEvent(lowSide: BasicObstacleSide): void;
    ProcessEventHB(highVertEvent: HighBendVertexEvent): void;
    EnqueueHighBendOrCloseVertexEvent(highSide: BasicObstacleSide): void;
    CreateCloseEventSegmentsAndFindNeighbors(closeVertEvent: CloseVertexEvent): void;
    ProcessEventCV(closeVertEvent: CloseVertexEvent): void;
    ProcessEventLR(lowIntEvent: LowReflectionEvent): void;
    ProcessEventHR(highIntEvent: HighReflectionEvent): void;
    MakeInBoundsLocation(location: Point): Point;
    IsInBoundsV(vertex: VisibilityVertex): boolean;
    IsInBoundsP(p: Point): boolean;
}
