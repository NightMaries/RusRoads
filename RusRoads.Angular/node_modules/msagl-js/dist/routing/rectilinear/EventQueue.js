//  Wrap the tree of events.
import { BinaryHeapWithComparer } from '../../structs/BinaryHeapWithComparer';
import { BasicReflectionEvent } from './basicReflectionEvent';
export class EventQueue {
    constructor() {
        this.eventTree = new BinaryHeapWithComparer((a, b) => this.Compare(a, b));
    }
    Reset(scanDir) {
        /*Assert.assert(0 == this.eventTree.Count, 'Stray events in EventQueue.Reset')*/
        this.scanDirection = scanDir;
    }
    Enqueue(evt) {
        this.eventTree.Enqueue(evt);
    }
    Dequeue() {
        const evt = this.eventTree.Dequeue();
        return evt;
    }
    get Count() {
        return this.eventTree.Count;
    }
    Compare(lhs, rhs) {
        if (lhs == rhs) {
            return 0;
        }
        if (lhs == null) {
            return -1;
        }
        if (rhs == null) {
            return 1;
        }
        //  First see if it's at the same scanline level (perpendicular coordinate).
        let cmp = this.scanDirection.ComparePerpCoord(lhs.Site, rhs.Site);
        if (cmp)
            return cmp;
        //  Event sites are at the same scanline level. Make sure that any reflection events are lowest (come before
        //  any side events, which could remove the side the reflection event was queued for).  We may have two
        //  reflection events at same coordinate, because we enqueue in two situations: when a side is opened,
        //  and when a side that is within that side's scanline-parallel span is closed.
        const lhsIsNotReflection = !(lhs instanceof BasicReflectionEvent) ? 1 : 0;
        const rhsIsNotReflection = !(rhs instanceof BasicReflectionEvent) ? 1 : 0;
        cmp = lhsIsNotReflection - rhsIsNotReflection;
        //  If the scanline-parallel coordinate is the same these events are at the same point.
        if (cmp)
            return cmp;
        return this.scanDirection.CompareScanCoord(lhs.Site, rhs.Site);
    }
}
//# sourceMappingURL=EventQueue.js.map