import { StringBuilder } from 'typescript-string-operations';
import { LinkedPoint } from './LinkedPoint';
///  represents the path for an GeomEdge
export class Path {
    ///  constructor
    ///  <param name="edgeGeometry"></param>
    constructor(edgeGeometry) {
        this.GeomEdge = edgeGeometry;
    }
    get PathPoints() {
        return this._pathPoints;
    }
    set PathPoints(value) {
        this._pathPoints = value;
    }
    get Width() {
        return this.GeomEdge.lineWidth;
    }
    get End() {
        return this.LastEdge.Target;
    }
    get Start() {
        return this.FirstEdge.Source;
    }
    ArrayOfPathPoints() {
        if (this._pathPoints instanceof LinkedPoint) {
            return Array.from(iteratePoints(this._pathPoints));
        }
        else {
            return this._pathPoints;
        }
    }
    *PathEdges() {
        for (let e = this.FirstEdge; e != null; e = e.Next) {
            yield e;
        }
    }
    AddEdge(edge) {
        edge.Path = this;
        /*Assert.assert(edge.Source == this.LastEdge.Target)*/
        this.LastEdge.Next = edge;
        edge.Prev = this.LastEdge;
        this.LastEdge = edge;
    }
    SetFirstEdge(edge) {
        this.FirstEdge = edge;
        this.LastEdge = edge;
        edge.Path = this;
    }
    ///
    ///  <returns></returns>
    toString() {
        const sb = new StringBuilder();
        if (this.PathPoints instanceof LinkedPoint)
            sb.Append('L');
        for (const p of iteratePoints(this.PathPoints))
            sb.Append(p.toString());
        return sb.ToString();
    }
}
function* iteratePoints(pathPoints) {
    if (pathPoints instanceof LinkedPoint) {
        for (let p = pathPoints; p != null; p = p.Next) {
            yield p.Point;
        }
    }
    else {
        for (const p of pathPoints)
            yield p;
    }
}
//# sourceMappingURL=Path.js.map