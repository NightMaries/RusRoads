import { Point, Rectangle, LineSegment, Polyline } from '../../../math/geometry';
import { RectangleNode } from '../../../math/geometry/RTree/RectangleNode';
import { RTree } from '../../../math/geometry/RTree/RTree';
import { Path } from './Path';
import { SegWithIndex } from './SegWithIndex';
export declare class StaircaseRemover {
    Paths: Array<Path>;
    HierarchyOfObstacles: RTree<Polyline, Point>;
    segTree: RTree<SegWithIndex, Point>;
    crossedOutPaths: Set<Path>;
    constructor(paths: Array<Path>, hierarchyOfObstacles: RectangleNode<Polyline, Point>);
    static RemoveStaircases(paths: Array<Path>, hierarchyOfObstacles: RectangleNode<Polyline, Point>): void;
    Calculate(): void;
    ProcessPath(path: Path): boolean;
    ProcessPoints(t: {
        pts: Point[];
        canHaveStaircase: boolean;
    }): boolean;
    FindStaircaseStart(t: {
        pts: Point[];
        canHaveStaircase: boolean;
    }): number;
    static GetFlippedPoint(pts: Point[], offset: number): Point;
    Crossing(a: Point, b: Point, segsToIgnore: SegWithIndex[]): boolean;
    static IsCrossing(ls: LineSegment, rTree: RTree<SegWithIndex, Point>, segsToIgnore: SegWithIndex[]): boolean;
    IntersectObstacleHierarchyPPP(a: Point, b: Point, c: Point): boolean;
    IntersectObstacleHierarchyL(ls: LineSegment): boolean;
    IsStaircase(pts: Point[], offset: number, segsToIgnore: SegWithIndex[], w: {
        canHaveStaircaseAtI: boolean;
    }): boolean;
    RemoveStaircasePN(pts: Point[], staircaseStart: number): Point[];
    RemoveStaircasePNB(pts: Point[], staircaseStart: number, horiz: boolean): Point[];
    RemoveSegs(pts: Point[]): void;
    RemoveSeg(seg: SegWithIndex): void;
    InsertNewSegs(pts: Point[], staircaseStart: number): void;
    InitHierarchies(): void;
    InsertPathSegs(path: Path): void;
    InsertSegs(pts: Point[]): void;
    InsSeg(pts: Point[], i: number): void;
    static Rect(seg: SegWithIndex): Rectangle;
}
