///  A place holder for an edge in a path to keep it inside of a linked list representing a path.
///  Each PathEdge belongs to only one path
import { CompassVector } from '../../../math/geometry/compassVector';
import { closeDistEps } from '../../../utils/compare';
///  In the last case the PathEdge is marked as Reversed. Several PathEdges can share the same AxisEdge.
export class PathEdge {
    constructor(edgeForNudging, width) {
        ///  A fixed edge cannot be shifted from its visibility edge; offset is always 0.
        ///  Such an edge can be, for example, a terminal edge going to a port.
        this.IsFixed = false;
        ///  if set to true then in the path the edge is reversed
        this.Reversed = false;
        this.index = -1;
        this.AxisEdge = edgeForNudging;
        this.Width = width;
    }
    toString() {
        return this.Source + (' ' + this.Target);
    }
    ///  It is the offset of the edge from the underlying line segment
    ///  [VisibilityEdge.SourcePoint, VisibilityEdge.TargetPoint] in to the direction of the VisibilityEdge.Perpendicular.
    ///  Offset holder is the same for the maximal parallel sequence of connected PathEdges
    get LongestNudgedSegment() {
        return this.longestNudgedSegment;
    }
    set LongestNudgedSegment(value) {
        this.longestNudgedSegment = value;
        if (this.longestNudgedSegment != null) {
            this.longestNudgedSegment.AddEdge(this);
            this.AxisEdge.AddLongestNudgedSegment(this.longestNudgedSegment);
        }
    }
    get Source() {
        return !this.Reversed ? this.AxisEdge.SourcePoint : this.AxisEdge.TargetPoint;
    }
    get Target() {
        return this.Reversed ? this.AxisEdge.SourcePoint : this.AxisEdge.TargetPoint;
    }
    static VectorsAreParallel(a, b) {
        return closeDistEps(a.x * b.y - a.y * b.x, 0);
    }
    static EdgesAreParallel(edge, pathEdge) {
        return PathEdge.VectorsAreParallel(edge.AxisEdge.TargetPoint.sub(edge.AxisEdge.SourcePoint), pathEdge.AxisEdge.TargetPoint.sub(pathEdge.AxisEdge.SourcePoint));
    }
    get Direction() {
        return this.Reversed ? CompassVector.OppositeDir(this.AxisEdge.Direction) : this.AxisEdge.Direction;
    }
    // not set yet
    ///  the index of the edge in the order
    get Index() {
        return this.index;
    }
    set Index(value) {
        this.index = value;
    }
}
//# sourceMappingURL=PathEdge.js.map