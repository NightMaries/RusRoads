import { Point, Rectangle, CompassVector, Curve, GeomConstants, LineSegment } from '../../../math/geometry';
import { RTree } from '../../../math/geometry/RTree/RTree';
import { closeDistEps } from '../../../utils/compare';
import { SegWithIndex } from './SegWithIndex';
export class StaircaseRemover {
    constructor(paths, hierarchyOfObstacles) {
        this.segTree = new RTree(null);
        this.crossedOutPaths = new Set();
        this.HierarchyOfObstacles = new RTree(hierarchyOfObstacles);
        this.Paths = paths;
    }
    static RemoveStaircases(paths, hierarchyOfObstacles) {
        const r = new StaircaseRemover(paths, hierarchyOfObstacles);
        r.Calculate();
    }
    Calculate() {
        this.InitHierarchies();
        let success;
        do {
            success = false;
            for (const path of this.Paths.filter((p) => !this.crossedOutPaths.has(p))) {
                if (this.ProcessPath(path))
                    success = true;
            }
        } while (success);
    }
    ProcessPath(path) {
        const t = { pts: path.PathPoints, canHaveStaircase: false };
        if (this.ProcessPoints(t)) {
            path.PathPoints = t.pts;
            return true;
        }
        if (!t.canHaveStaircase) {
            this.crossedOutPaths.add(path);
        }
        return false;
    }
    ProcessPoints(t) {
        const staircaseStart = this.FindStaircaseStart(t);
        if (staircaseStart < 0) {
            return false;
        }
        t.pts = this.RemoveStaircasePN(t.pts, staircaseStart);
        return true;
    }
    FindStaircaseStart(t) {
        t.canHaveStaircase = false;
        if (t.pts.length < 5) {
            return -1;
        }
        const segs = [new SegWithIndex(t.pts, 0), new SegWithIndex(t.pts, 1), new SegWithIndex(t.pts, 2), new SegWithIndex(t.pts, 3)];
        let segToReplace = 0;
        for (let i = 0;;) {
            const w = { canHaveStaircaseAtI: false };
            if (this.IsStaircase(t.pts, i, segs, w)) {
                t.canHaveStaircase = true;
                return i;
            }
            t.canHaveStaircase = t.canHaveStaircase || w.canHaveStaircaseAtI;
            i++;
            if (t.pts.length < i + 5) {
                return -1;
            }
            segs[segToReplace] = new SegWithIndex(t.pts, i + 3);
            segToReplace++;
            segToReplace %= 4;
        }
    }
    static GetFlippedPoint(pts, offset) {
        const horiz = closeDistEps(pts[offset].y, pts[offset + 1].y);
        return horiz ? new Point(pts[offset + 4].x, pts[offset].y) : new Point(pts[offset].x, pts[offset + 4].y);
    }
    ///  ignoring crossing at a
    ///  <param name="a"></param>
    ///  <param name="b"></param>
    ///  <param name="segsToIgnore"></param>
    ///  <returns></returns>
    Crossing(a, b, segsToIgnore) {
        return StaircaseRemover.IsCrossing(LineSegment.mkPP(a, b), this.segTree, segsToIgnore);
    }
    ///  ignoring crossing at ls.Start
    ///  <param name="ls"></param>
    ///  <param name="rTree"></param>
    ///  <param name="segsToIgnore"></param>
    ///  <returns></returns>
    static IsCrossing(ls, rTree, segsToIgnore) {
        for (const seg of rTree.GetAllIntersecting(ls.boundingBox))
            if (segsToIgnore.findIndex((p) => p == seg) == -1)
                return true;
        return false;
    }
    IntersectObstacleHierarchyPPP(a, b, c) {
        return this.IntersectObstacleHierarchyL(LineSegment.mkPP(a, b)) || this.IntersectObstacleHierarchyL(LineSegment.mkPP(b, c));
    }
    IntersectObstacleHierarchyL(ls) {
        return this.HierarchyOfObstacles.GetAllIntersecting(ls.boundingBox).some((poly) => Curve.intersectionOne(ls, poly, false) != null);
    }
    IsStaircase(pts, offset, segsToIgnore, w) {
        const a = pts[offset];
        const b = pts[offset + 1];
        let c = pts[offset + 2];
        const d = pts[offset + 3];
        const f = pts[offset + 4];
        w.canHaveStaircaseAtI = false;
        if (CompassVector.DirectionFromPointToPoint(a, b) != CompassVector.DirectionFromPointToPoint(c, d) ||
            CompassVector.DirectionFromPointToPoint(b, c) != CompassVector.DirectionFromPointToPoint(d, f)) {
            return false;
        }
        c = StaircaseRemover.GetFlippedPoint(pts, offset);
        if (this.IntersectObstacleHierarchyPPP(b, c, d)) {
            return false;
        }
        w.canHaveStaircaseAtI = true;
        return !this.Crossing(b, c, segsToIgnore);
    }
    RemoveStaircasePN(pts, staircaseStart) {
        const a = pts[staircaseStart];
        const b = pts[staircaseStart + 1];
        const horiz = Math.abs(a.y - b.y) < GeomConstants.distanceEpsilon / 2;
        return this.RemoveStaircasePNB(pts, staircaseStart, horiz);
    }
    RemoveStaircasePNB(pts, staircaseStart, horiz) {
        this.RemoveSegs(pts);
        const ret = new Array(pts.length - 2);
        ArrayCopyAAN(pts, ret, staircaseStart + 1);
        const a = pts[staircaseStart + 1];
        const c = pts[staircaseStart + 3];
        ret[staircaseStart + 1] = horiz ? new Point(c.x, a.y) : new Point(a.x, c.y);
        ArrayCopyANANN(pts, staircaseStart + 4, ret, staircaseStart + 2, ret.length - staircaseStart - 2);
        this.InsertNewSegs(ret, staircaseStart);
        return ret;
    }
    RemoveSegs(pts) {
        for (let i = 0; i < pts.length - 1; i++) {
            this.RemoveSeg(new SegWithIndex(pts, i));
        }
    }
    RemoveSeg(seg) {
        this.segTree.Remove(StaircaseRemover.Rect(seg), seg);
    }
    InsertNewSegs(pts, staircaseStart) {
        this.InsSeg(pts, staircaseStart);
        this.InsSeg(pts, staircaseStart + 1);
    }
    InitHierarchies() {
        for (const path of this.Paths) {
            this.InsertPathSegs(path);
        }
    }
    InsertPathSegs(path) {
        this.InsertSegs(path.PathPoints);
    }
    InsertSegs(pts) {
        for (let i = 0; i < pts.length - 1; i++) {
            this.InsSeg(pts, i);
        }
    }
    InsSeg(pts, i) {
        const seg = new SegWithIndex(pts, i);
        this.segTree.Add(StaircaseRemover.Rect(seg), seg);
    }
    static Rect(seg) {
        return Rectangle.mkPP(seg.Start, seg.End);
    }
}
function ArrayCopyANANN(a, ai, b, bi, length) {
    while (length-- > 0) {
        b[bi++] = a[ai++];
    }
}
function ArrayCopyAAN(a, b, length) {
    /*Assert.assert(a.length >= length)*/
    /*Assert.assert(b.length >= length)*/
    let i = 0;
    while (length-- > 0) {
        b[i++] = a[i++];
    }
}
//# sourceMappingURL=StaircaseRemover.js.map