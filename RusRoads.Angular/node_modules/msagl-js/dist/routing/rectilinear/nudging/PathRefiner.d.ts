import { Point } from '../../../math/geometry/point';
import { Direction } from '../../../math/geometry/direction';
import { LinkedPoint } from './LinkedPoint';
import { Path } from './Path';
declare type PointProjection = (p: Point) => number;
export declare class PathRefiner {
    static RefinePaths(paths: Array<Path>, mergePaths: boolean): void;
    static AdjustPaths(paths: Array<Path>): void;
    static AdjustPathPoints(points: Array<Point>): Array<Point>;
    static CrossVerticalAndHorizontalSegs(pathsFirstLinked: Iterable<LinkedPoint>): void;
    static ReconstructPathsFromLinkedVertices(pathsToPathLinkedPoints: Map<Path, LinkedPoint>): void;
    static Refine(pathFirstPoints: Array<LinkedPoint>): void;
    static groupByProj(proj: (a: Point) => number, linkedPointsInDirection: LinkedPoint[]): IterableIterator<Array<LinkedPoint>>;
    static RefineInDirection(direction: Direction, pathFirstPoints: Iterable<LinkedPoint>): void;
    static GetProjectionsDelegates(direction: Direction, t: {
        projectionToPerp: PointProjection;
        projectionToDirection: PointProjection;
    }): void;
    static GetAllLinkedVertsInDirection(projectionToPerp: PointProjection, initialVerts: Iterable<LinkedPoint>): IterableIterator<LinkedPoint>;
    static RefineCollinearBucket(pathLinkedVertices: Iterable<LinkedPoint>, projectionToDirection: PointProjection): void;
    static InsertPoints(pathLinkedVertex: LinkedPoint, arrayOfPoints: Point[], i: number, j: number): void;
    static CreatePathsToFirstLinkedVerticesMap(edgePaths: Iterable<Path>): Map<Path, LinkedPoint>;
    static CreateLinkedVertexOfEdgePath(path: Path): LinkedPoint;
}
export {};
