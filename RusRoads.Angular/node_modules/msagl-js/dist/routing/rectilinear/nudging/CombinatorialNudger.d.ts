import { Queue } from 'queue-typescript';
import { Point } from '../../../math/geometry/point';
import { Direction } from '../../../math/geometry/direction';
import { VisibilityEdge } from '../../visibility/VisibilityEdge';
import { VisibilityGraph } from '../../visibility/VisibilityGraph';
import { VisibilityVertex } from '../../visibility/VisibilityVertex';
import { AxisEdge } from './AxisEdge';
import { Path } from './Path';
import { PathEdge } from './PathEdge';
export declare class CombinatorialNudger {
    static readonly NotOrdered: number;
    pathVisibilityGraph: VisibilityGraph;
    get PathVisibilityGraph(): VisibilityGraph;
    axisEdgesToPathOrders: Map<AxisEdge, Array<PathEdge>>;
    constructor(paths: Array<Path>);
    OriginalPaths: Iterable<Path>;
    GetOrder(): Map<AxisEdge, Array<PathEdge>>;
    FillTheVisibilityGraphByWalkingThePaths(): void;
    FillTheVisibilityGraphByWalkingPath(path: Path): void;
    CreatePathEdgesFromPoints(pathPoints: IterableIterator<Point>, width: number): IterableIterator<PathEdge>;
    CreatePathEdge(p0: Point, p1: Point, width: number): PathEdge;
    GetAxisEdge(p0: Point, p1: Point): AxisEdge;
    InitPathOrder(): void;
    OrderPaths(): void;
    OrderPathEdgesSharingEdge(edge: AxisEdge): void;
    static CompareTwoPathEdges(x: PathEdge, y: PathEdge): number;
    static CompareInDirectionStartingFromAxisEdge(x: PathEdge, y: PathEdge, axisEdge: AxisEdge, direction: Direction): number;
    static FindContinuedDirection(edge: AxisEdge, direction: Direction, nextAxisEdge: AxisEdge): Direction;
    static OtherVertex(axisEdge: VisibilityEdge, v: VisibilityVertex): VisibilityVertex;
    static ProjectionForCompare(axisEdge: AxisEdge, isReversed: boolean): (p: Point) => number;
    static GetNextPathEdgeInDirection(e: PathEdge, axisEdge: AxisEdge, direction: Direction): PathEdge;
    static GetExistingOrder(x: PathEdge, y: PathEdge): number;
    PathOrderOfVisEdge(axisEdge: AxisEdge): Array<PathEdge>;
    static InitQueueOfSources(queue: Queue<VisibilityVertex>, dictionary: Map<VisibilityVertex, number>, graph: VisibilityGraph): void;
    static WalkGraphEdgesInTopologicalOrderIfPossible(visibilityGraph: VisibilityGraph): IterableIterator<AxisEdge>;
}
