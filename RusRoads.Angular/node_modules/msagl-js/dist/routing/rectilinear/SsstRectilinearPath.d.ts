import { Point } from '../../math/geometry/point';
import { Direction } from '../../math/geometry/direction';
import { VisibilityVertex } from '../visibility/VisibilityVertex';
import { VertexEntry } from './VertexEntry';
import { VisibilityVertexRectilinear } from './VisibilityVertexRectiline';
export declare class SsstRectilinearPath {
    LengthImportance: number;
    BendsImportance: number;
    static DefaultBendPenaltyAsAPercentageOfDistance: number;
    Target: VisibilityVertexRectilinear;
    Source: VisibilityVertexRectilinear;
    EntryDirectionsToTarget: Direction;
    private upperBoundOnCost;
    private sourceCostAdjustment;
    private targetCostAdjustment;
    private CombinedCost;
    private TotalCostFromSourceToVertex;
    private queue;
    private visitedVertices;
    private readonly nextNeighbors;
    constructor();
    private InitPath;
    private InitEntryDirectionsAtTarget;
    private static IsInDirs;
    MultistageAdjustedCostBound(bestCost: number): number;
    private HeuristicDistanceFromVertexToTarget;
    private GetNumberOfBends;
    private GetNumberOfBendsForPureDirection;
    private static GetBendsForNotPureDirection;
    private static AddOneTurn;
    private static Left;
    private static Right;
    static RestorePathV(t: {
        entry: VertexEntry;
    }): Array<Point>;
    static RestorePath(t: {
        entry: VertexEntry;
    }, firstVertexInStage: VisibilityVertex): Array<Point>;
    private QueueReversedEntryToNeighborVertexIfNeeded;
    private UpdateEntryToNeighborVertexIfNeeded;
    private CreateAndEnqueueEntryToNeighborVertex;
    private EnqueueEntry;
    private static GetLengthAndNumberOfBendsToNeighborVertex;
    static ManhattanDistance(a: Point, b: Point): number;
    GetPathWithCost(sourceVertexEntries: VertexEntry[], source: VisibilityVertexRectilinear, adjustmentToSourceCost: number, targetVertexEntries: VertexEntry[], target: VisibilityVertexRectilinear, adjustmentToTargetCost: number, priorBestCost: number): VertexEntry;
    private ExtendPathAlongInEdges;
    private ExtendPathAlongOutEdges;
    private ExtendPathAlongEdge;
    private EnqueueInitialVerticesFromSource;
    private EnqueueInitialVerticesFromSourceEntries;
    private ExtendPathToNeighborVertex;
    private CreateAndEnqueueReversedEntryToNeighborVertex;
    private static IsPassable;
    private Cleanup;
}
