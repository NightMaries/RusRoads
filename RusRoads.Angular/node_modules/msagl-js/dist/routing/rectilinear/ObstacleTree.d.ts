import { Point, Rectangle } from '../..';
import { Direction, LineSegment } from '../../math/geometry';
import { HitTestBehavior } from '../../math/geometry/RTree/HitTestBehavior';
import { RectangleNode } from '../../math/geometry/RTree/RectangleNode';
import { Shape } from '../shape';
import { GroupBoundaryCrossingMap } from './GroupBoundaryCrossingMap';
import { Obstacle } from './obstacle';
import { PointAndCrossingsList } from './PointAndCrossingsList';
import { ScanDirection } from './ScanDirection';
export declare class ObstacleTree {
    insideHitTestIgnoreObstacle1: Obstacle;
    insideHitTestIgnoreObstacle2: Obstacle;
    insideHitTestScanDirection: ScanDirection;
    Root: RectangleNode<Obstacle, Point>;
    get GraphBox(): Rectangle;
    AncestorSets: Map<Shape, Set<Shape>>;
    SpatialAncestorsAdjusted: boolean;
    private shapeIdToObstacleMap;
    CurrentGroupBoundaryCrossingMap: GroupBoundaryCrossingMap;
    private allObstacles;
    private overlapPairs;
    private hasOverlaps;
    private lookupIntPair;
    Init(obstacles: Iterable<Obstacle>, ancestorSets: Map<Shape, Set<Shape>>, idToObstacleMap: Map<Shape, Obstacle>): void;
    private CreateObstacleListAndOrdinals;
    private OrdinalToObstacle;
    private CreateRoot;
    private OverlapsExist;
    private OverlapPairAlreadyFound;
    private CheckForInitialOverlaps;
    private AccreteClumps;
    private AccreteConvexHulls;
    static CalculateHierarchy(obstacles: Iterable<Obstacle>): RectangleNode<Obstacle, Point>;
    private AccumulateObstaclesForClumps;
    private EvaluateOverlappedPairForClump;
    private AccumulateObstaclesForConvexHulls;
    private EvaluateOverlappedPairForConvexHull;
    GrowGroupsToAccommodateOverlaps(): void;
    private AccumulateObstaclesForGroupOverlaps;
    private EvaluateOverlappedPairForGroup;
    private static FirstRectangleContainsACornerOfTheOther;
    private static FirstPolylineStartIsInsideSecondPolyline;
    private AddClumpToConvexHull;
    private AddConvexHullToConvexHull;
    private CreateClumps;
    private CreateConvexHulls;
    private GrowGroupsToResolveOverlaps;
    private static ResolveGroupAndGroupOverlap;
    private static ResolveGroupAndObstacleOverlap;
    private static GrowGroupAroundLoosePolyline;
    static ObstaclesIntersect(a: Obstacle, b: Obstacle, t: {
        aIsInsideB: boolean;
        bIsInsideA: boolean;
    }): boolean;
    private static ObstaclesAreCloseEnoughToBeConsideredTouching;
    AdjustSpatialAncestors(): boolean;
    GetAllGroups(): Array<Obstacle>;
    Clear(): void;
    CreateMaxVisibilitySegment(startPoint: Point, dir: Direction, t: {
        pacList: PointAndCrossingsList;
    }): LineSegment;
    GetAllObstacles(): Array<Obstacle>;
    GetAllPrimaryObstacles(): Iterable<Obstacle>;
    IntersectionIsInsideAnotherObstacle(sideObstacle: Obstacle, eventObstacle: Obstacle, intersect: Point, scanDirection: ScanDirection): boolean;
    PointIsInsideAnObstaclePD(intersect: Point, direction: Direction): boolean;
    PointIsInsideAnObstacle(intersect: Point, scanDirection: ScanDirection): boolean;
    InsideObstacleHitTest(location: Point, obstacle: Obstacle): HitTestBehavior;
    SegmentCrossesAnObstacle(startPoint: Point, endPoint: Point): boolean;
    SegmentCrossesANonGroupObstacle(startPoint: Point, endPoint: Point): boolean;
    RestrictSegmentWithObstacles(startPoint: Point, endPoint: Point): LineSegment;
    private RestrictSegmentPrivate;
    private GetRestrictedIntersectionTestSegment;
    restrictedIntersectionTestSegment: LineSegment;
    currentRestrictedRay: LineSegment;
    wantGroupCrossings: boolean;
    stopAtGroups: boolean;
    restrictedRayLengthSquared: number;
    private RecurseRestrictRayWithObstacles;
    private LookForCloserNonGroupIntersectionToRestrictRay;
    private AddGroupIntersectionsToRestrictedRay;
}
