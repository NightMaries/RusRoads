import { Point, Rectangle, Direction, LineSegment } from '../../math/geometry';
import { TollFreeVisibilityEdge } from '../visibility/TollFreeVisibilityEdge';
import { VisibilityEdge } from '../visibility/VisibilityEdge';
import { VisibilityGraph } from '../visibility/VisibilityGraph';
import { VisibilityVertex } from '../visibility/VisibilityVertex';
import { ObstacleTree } from './ObstacleTree';
import { PointAndCrossingsList } from './PointAndCrossingsList';
import { VisibilityGraphGenerator } from './VisibilityGraphGenerator';
import { VisibilityVertexRectilinear } from './VisibilityVertexRectiline';
export declare class TransientGraphUtility {
    AddedVertices: Array<VisibilityVertexRectilinear>;
    AddedEdges: Array<TollFreeVisibilityEdge>;
    edgesToRestore: Array<VisibilityEdge>;
    LimitPortVisibilitySpliceToEndpointBoundingBox: boolean;
    GraphGenerator: VisibilityGraphGenerator;
    get ObstacleTree(): ObstacleTree;
    get VisGraph(): VisibilityGraph;
    private get IsSparseVg();
    constructor(graphGen: VisibilityGraphGenerator);
    AddVertex(location: Point): VisibilityVertex;
    FindOrAddVertex(location: Point): VisibilityVertex;
    FindOrAddEdgeVV(sourceVertex: VisibilityVertex, targetVertex: VisibilityVertex): VisibilityEdge;
    FindOrAddEdge(sourceVertex: VisibilityVertex, targetVertex: VisibilityVertex, weight: number): VisibilityEdge;
    private static GetBrackets;
    static FindBracketingVertices(sourceVertex: VisibilityVertex, targetPoint: Point, dirToTarget: Direction, t: {
        bracketSource: VisibilityVertex;
        bracketTarget: VisibilityVertex;
    }): boolean;
    private CreateEdge;
    RemoveFromGraph(): void;
    private RemoveAddedVertices;
    private RemoveAddedEdges;
    private RestoreRemovedEdges;
    FindNextEdge(vertex: VisibilityVertex, dir: Direction): VisibilityEdge;
    FindPerpendicularOrContainingEdge(startVertex: VisibilityVertex, dir: Direction, pointLocation: Point): VisibilityEdge;
    FindNearestPerpendicularOrContainingEdge(startVertex: VisibilityVertex, dir: Direction, pointLocation: Point): VisibilityEdge;
    ConnectVertexToTargetVertex(sourceVertex: VisibilityVertex, targetVertex: VisibilityVertex, finalEdgeDir: Direction, weight: number): void;
    AddEdgeToTargetEdge(sourceVertex: VisibilityVertex, targetEdge: VisibilityEdge, targetIntersect: Point): VisibilityVertex;
    SplitEdge(edge: VisibilityEdge, splitVertex: VisibilityVertex): VisibilityEdge;
    ExtendEdgeChainVRLPB(startVertex: VisibilityVertex, limitRect: Rectangle, maxVisibilitySegment: LineSegment, pacList: PointAndCrossingsList, isOverlapped: boolean): void;
    ExtendEdgeChain(startVertex: VisibilityVertex, extendDir: Direction, maxDesiredSegment: LineSegment, maxVisibilitySegment: LineSegment, pacList: PointAndCrossingsList, isOverlapped: boolean): void;
    private SpliceGroupBoundaryCrossings;
    private static TraverseToFirstVertexAtOrAbove;
    private SpliceGroupBoundaryCrossing;
    ExtendSpliceWorker(spliceSourcePar: VisibilityVertex, extendDir: Direction, spliceTargetDir: Direction, maxDesiredSegment: LineSegment, maxVisibilitySegment: LineSegment, isOverlapped: boolean, t: {
        spliceTarget: VisibilityVertex;
    }): boolean;
    private static GetNextSpliceSource;
    private static GetSpliceTarget;
    private SeeIfSpliceIsStillOverlapped;
    IsSkippableSpliceSourceWithNullSpliceTarget(spliceSource: VisibilityVertex, extendDir: Direction): boolean;
    static IsSkippableSpliceSourceEdgeWithNullTarget(spliceSourceEdge: VisibilityEdge): boolean;
    static IsReflectionEdge(edge: VisibilityEdge): boolean;
    static IsPointPastSegmentEnd(maxSegment: LineSegment, point: Point): boolean;
    toString(): string;
}
