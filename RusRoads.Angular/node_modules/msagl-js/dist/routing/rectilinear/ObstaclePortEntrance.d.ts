import { Point, Rectangle, Direction, LineSegment } from '../../math/geometry';
import { VisibilityVertex } from '../visibility/VisibilityVertex';
import { Obstacle } from './obstacle';
import { ObstaclePort } from './ObstaclePort';
import { ObstacleTree } from './ObstacleTree';
import { TransientGraphUtility } from './TransientGraphUtility';
export declare class ObstaclePortEntrance {
    ObstaclePort: ObstaclePort;
    get Obstacle(): Obstacle;
    UnpaddedBorderIntersect: Point;
    OutwardDirection: Direction;
    VisibilityBorderIntersect: Point;
    IsOverlapped: boolean;
    get InitialWeight(): number;
    private unpaddedToPaddedBorderWeight;
    get IsCollinearWithPort(): boolean;
    MaxVisibilitySegment: LineSegment;
    private pointAndCrossingsList;
    get IsVertical(): boolean;
    get WantVisibilityIntersection(): boolean;
    get CanExtend(): boolean;
    constructor(oport: ObstaclePort, unpaddedBorderIntersect: Point, outDir: Direction, obstacleTree: ObstacleTree);
    private SetUnpaddedToPaddedBorderWeightFromHullSiblingOverlaps;
    private InteriorEdgeCrossesObstacle;
    private InteriorEdgeCrossesConvexHullSiblings;
    private InteriorEdgeCrossesObstacleRFI;
    get HasGroupCrossings(): boolean;
    HasGroupCrossingBeforePoint(point: Point): boolean;
    AddToAdjacentVertex(transUtil: TransientGraphUtility, targetVertex: VisibilityVertex, limitRect: Rectangle, routeToCenter: boolean): void;
    ExtendEdgeChain(transUtil: TransientGraphUtility, paddedBorderVertex: VisibilityVertex, targetVertex: VisibilityVertex, limitRect: Rectangle, routeToCenter: boolean): void;
    toString(): string;
}
