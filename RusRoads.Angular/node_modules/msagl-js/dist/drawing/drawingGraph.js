import { DrawingEdge } from '.';
import { CurveFactory, GeomEdge, GeomGraph, GeomLabel, GeomNode, Point, Rectangle, Size } from '..';
import { Ellipse } from '../math/geometry/ellipse';
import { DrawingNode } from './drawingNode';
import { DrawingObject } from './drawingObject';
import { ShapeEnum } from './shapeEnum';
export class DrawingGraph extends DrawingNode {
    constructor() {
        super(...arguments);
        // but serves as a template for the attributes (like filledColor, style, etc.)
        this.graphVisData = {
            sameRanks: new Array(),
            minRanks: new Array(),
            maxRanks: new Array(),
            sourceRanks: new Array(),
            sinkRanks: new Array(),
        };
    }
    get graph() {
        return this.attrCont;
    }
    findNode(id) {
        const gr = this.graph;
        const n = gr.findNode(id);
        if (n == null)
            return null;
        return DrawingObject.getDrawingObj(n);
    }
    hasDirectedEdge() {
        for (const e of this.graph.edges) {
            const drawingEdge = DrawingObject.getDrawingObj(e);
            if (drawingEdge.directed) {
                return true;
            }
        }
        return false;
    }
    createGeometry(textMeasure = (str) => {
        if (!str)
            return null;
        return new Size(str.length * 8 + 8, 20);
    }) {
        const geomGraph = new GeomGraph(this.graph);
        geomGraph.labelSize = textMeasure(this.labelText);
        for (const n of this.graph.deepNodes) {
            this.createNodeGeometry(n, textMeasure);
        }
        for (const e of this.graph.edges) {
            this.createEdgeGeometry(e, textMeasure);
        }
    }
    createEdgeGeometry(e, textMeasure) {
        const de = DrawingEdge.getDrawingObj(e);
        const ge = new GeomEdge(e);
        if (de.directed == false) {
            ge.targetArrowhead = null;
        }
        if (e.label) {
            const size = textMeasure(e.label.text);
            ge.label = new GeomLabel(Rectangle.mkPP(new Point(0, 0), new Point(size.width, size.height)), e.label);
        }
    }
    curveByShape(width, height, center, shape, drawingNode) {
        let curve;
        switch (shape) {
            case ShapeEnum.diamond:
                curve = CurveFactory.CreateDiamond(width, height, center);
                break;
            case ShapeEnum.ellipse:
                break;
            case ShapeEnum.box:
                curve = CurveFactory.mkRectangleWithRoundedCorners(width, height, drawingNode.XRadius, drawingNode.YRadius, center);
                break;
            case ShapeEnum.circle:
                curve = CurveFactory.mkCircle(width / 2, center);
                break;
            case ShapeEnum.record:
                break;
            case ShapeEnum.plaintext:
                break;
            case ShapeEnum.point:
                break;
            case ShapeEnum.mdiamond:
                break;
            case ShapeEnum.msquare:
                break;
            case ShapeEnum.polygon:
                break;
            case ShapeEnum.doublecircle:
                curve = CurveFactory.mkCircle(width / 2, center);
                break;
            case ShapeEnum.house:
                curve = CurveFactory.createHouse(width, height, center);
                break;
            case ShapeEnum.invhouse:
                curve = CurveFactory.createInvertedHouse(width, height, center);
                break;
            case ShapeEnum.parallelogram:
                break;
            case ShapeEnum.octagon:
                curve = CurveFactory.createOctagon(width, height, center);
                break;
            case ShapeEnum.tripleoctagon:
                break;
            case ShapeEnum.triangle:
                break;
            case ShapeEnum.trapezium:
                break;
            case ShapeEnum.drawfromgeometry:
                break;
            case ShapeEnum.hexagon:
                curve = CurveFactory.createHexagon(width, height, center);
                break;
        }
        return curve !== null && curve !== void 0 ? curve : Ellipse.mkFullEllipseNNP(width / 2, height / 2, center);
    }
    createNodeGeometry(n, textMeasure) {
        if (n.isGraph) {
            const subDg = DrawingObject.getDrawingObj(n);
            subDg.createGeometry(textMeasure);
        }
        else {
            const drawingNode = DrawingNode.getDrawingObj(n);
            let textSize = new Size(1, 1);
            if (drawingNode.labelText) {
                textSize = textMeasure(drawingNode.labelText);
            }
            const width = textSize.width + drawingNode.LabelMargin * 2;
            const height = textSize.height + drawingNode.LabelMargin * 2;
            const center = new Point(0, 0);
            const geomNode = new GeomNode(n);
            geomNode.boundaryCurve = this.curveByShape(width, height, center, drawingNode.shape, drawingNode);
        }
    }
}
//# sourceMappingURL=drawingGraph.js.map