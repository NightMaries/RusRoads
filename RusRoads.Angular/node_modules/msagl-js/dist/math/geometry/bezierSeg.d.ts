import { ICurve } from './icurve';
import { Rectangle } from './rectangle';
import { PN } from './parallelogramNode';
import { Point } from './point';
import { PlaneTransformation } from './planeTransformation';
export declare class BezierSeg implements ICurve {
    leftDerivative(t: number): Point;
    rightDerivative(t: number): Point;
    b: Point[];
    l: Point;
    e: Point;
    c: Point;
    B(controlPointIndex: number): Point;
    pBoxNode: PN;
    pNodeOverICurve(): PN;
    value(t: number): Point;
    static adjustParamTo01(u: number): number;
    trim(u: number, v: number): ICurve;
    trimWithWrap(start: number, end: number): ICurve;
    casteljau(t: number, b1: Point[], b2: Point[]): Point;
    derivative(t: number): Point;
    secondDerivative(t: number): Point;
    thirdDerivative(t: number): Point;
    constructor(b0: Point, b1: Point, b2: Point, b3: Point);
    get start(): Point;
    get end(): Point;
    reverse(): BezierSeg;
    translate(delta: Point): void;
    scaleFromOrigin(xScale: number, yScale: number): BezierSeg;
    offsetCurve(offset: number, dir: Point): ICurve;
    lengthPartial(start: number, end: number): number;
    get length(): number;
    static lengthOnControlPolygon(b0: Point, b1: Point, b2: Point, b3: Point): number;
    get boundingBox(): Rectangle;
    transform(transformation: PlaneTransformation): BezierSeg;
    closestParameterWithinBounds(targetPoint: Point, low: number, high: number): number;
    clone(): BezierSeg;
    static mkBezier(b: Point[]): BezierSeg;
    parStart: number;
    parEnd: number;
    curvature(t: number): number;
    F(t: number): number;
    G(t: number): number;
    Xp(t: number): number;
    Ypp(t: number): number;
    Yp(t: number): number;
    Xpp(t: number): number;
    Xppp(t: number): number;
    Yppp(t: number): number;
    curvatureDerivative(t: number): number;
    Fp(t: number): number;
    Fpp(t: number): number;
    closestParameter(targetPoint: Point): number;
    curvatureSecondDerivative(t: number): number;
    Q(t: number): number;
    Qp(t: number): number;
    Gpp(t: number): number;
    Gp(t: number): number;
    getParameterAtLength(length: number): number;
    evaluateError(length: number, t: number): 1 | 0 | -1;
}
