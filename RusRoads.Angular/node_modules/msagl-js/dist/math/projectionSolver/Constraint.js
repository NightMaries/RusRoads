import { String } from 'typescript-string-operations';
import { compareNumbers } from '../../utils/compare';
export class Constraint {
    //  For Solver.ComputeDfDv's DummyParentNode's constraint only.
    constructor(variable) {
        this.Right = variable;
        this.Left = variable;
    }
    SetActiveState(activeState, newVectorIndex) {
        //  Note: newVectorIndex may be the same as the old one if we are changing the state
        //  of the last inactive or first active constraint.
        /*Assert.assert(
          this.IsActive != activeState,
          'Constraint is already set to activationState',
        )*/
        this.IsActive = activeState;
        this.VectorIndex = newVectorIndex;
        if (this.IsActive) {
            this.Left.ActiveConstraintCount++;
            this.Right.ActiveConstraintCount++;
        }
        else {
            this.Left.ActiveConstraintCount--;
            this.Right.ActiveConstraintCount--;
        }
    }
    SetVectorIndex(vectorIndex) {
        //  This is separate from set_VectorIndex because we can't restrict the caller to a specific
        //  class and we only want ConstraintVector to be able to call this.
        this.VectorIndex = vectorIndex;
    }
    Reinitialize() {
        //  Called by Qpsc or equivalence-constraint-regapping initial block restructuring.
        //  All variables have been moved to their own blocks again, so reset solution states.
        this.IsActive = false;
        this.IsUnsatisfiable = false;
        this.ClearDfDv();
    }
    //  This is an  function, not a propset, because we only want it called by the Solver.
    UpdateGap(newGap) {
        this.Gap = newGap;
    }
    //  The Constraint constructor takes the two variables and their required distance.
    //  The constraints will be generated either manually or by ConstraintGenerator,
    //  both of which know about the sizes when the constraints are generated (as
    //  well as any necessary padding), so the sizes are accounted for at that time
    //  and ProjectionSolver classes are not aware of Variable sizes.
    static constructorVVNB(left, right, gap, isEquality) {
        const v = new Constraint(left);
        v.Left = left;
        v.Right = right;
        v.Gap = gap;
        v.IsEquality = isEquality;
        v.Lagrangian = 0;
        v.IsActive = false;
        return v;
    }
    ///  Generates a string representation of the Constraint.
    ///  <returns>A string representation of the Constraint.</returns>
    ToString() {
        return String.Format('  Cst: [{0}] [{1}] {2} {3:F5} vio {4:F5} Lm {5:F5}/{6:F5} {7}actv', this.Left, this.Right, this.IsEquality ? '==' : '>=', this.Gap, this.Violation, this.Lagrangian, this.Lagrangian * 2, this.IsActive ? '+' : this.IsUnsatisfiable ? '!' : '-');
    }
    get Violation() {
        return this.Left.ActualPos * this.Left.Scale + (this.Gap - this.Right.ActualPos * this.Right.Scale);
    }
    ClearDfDv() {
        this.Lagrangian = 0;
    }
    ///  Compare this Constraint to rhs by their Variables in ascending order (this == lhs, other == rhs).
    ///  <param name="other">The object being compared to.</param>
    ///  <returns>-1 if this.Left/Right are "less"; +1 if this.Left/Right are "greater"; 0 if this.Left/Right
    ///          and rhs.Left/Right are equal.</returns>
    CompareTo(other) {
        let cmp = this.Left.CompareTo(other.Left);
        if (0 == cmp) {
            cmp = this.Right.CompareTo(other.Right);
        }
        if (0 == cmp) {
            cmp = compareNumbers(this.Gap, other.Gap);
        }
        return cmp;
    }
}
//# sourceMappingURL=Constraint.js.map