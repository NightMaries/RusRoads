import { Stack } from 'stack-typescript';
export class ConstraintVector {
    constructor() {
        this.nextConstraintIndex = 0;
        //  The node stack for "recursive iteration" of constraint trees, and the recycled node stack
        //  to reduce inner-loop alloc/GC overhead.
        this.DfDvStack = new Stack();
        this.DfDvRecycleStack = new Stack();
    }
    get IsEmpty() {
        return this.Vector == null;
    }
    Create(numConstraints) {
        this.Vector = new Array(numConstraints);
        //  Initialize this to out of range.
        this.firstActiveConstraintIndex = numConstraints;
    }
    Add(constraint) {
        /*Assert.assert(!constraint.IsActive, 'Constraint should not be active')*/
        constraint.SetVectorIndex(this.nextConstraintIndex);
        this.Vector[this.nextConstraintIndex++] = constraint;
    }
    ActivateConstraint(constraint) {
        /*Assert.assert(!constraint.IsActive, 'Constraint is already active')*/
        //  Swap it from the inactive region to the start of the active region of the Vector.
        /*Assert.assert(
          this.firstActiveConstraintIndex > 0,
          'All constraints are already active',
        )*/
        this.firstActiveConstraintIndex--;
        /*Assert.assert(
          !this.Vector[this.firstActiveConstraintIndex].IsActive,
          'Constraint in inactive region is active',
        )*/
        this.SwapConstraint(constraint);
        // Debug_AssertConsistency();
    }
    DeactivateConstraint(constraint) {
        /*Assert.assert(constraint.IsActive, 'Constraint is not active')*/
        //  Swap it from the active region to the end of the inactive region of the Vector.
        /*Assert.assert(
          this.firstActiveConstraintIndex < this.Vector.length,
          'All constraints are already inactive',
        )*/
        /*Assert.assert(
          this.Vector[this.firstActiveConstraintIndex].IsActive,
          'Constraint in active region is not active',
        )*/
        this.SwapConstraint(constraint);
        this.firstActiveConstraintIndex++;
        // Debug_AssertConsistency();
    }
    SwapConstraint(constraint) {
        //  Swap out the constraint at the current active/inactive border index (which has been updated
        //  according to the direction we're moving it).
        const swapConstraint = this.Vector[this.firstActiveConstraintIndex];
        swapConstraint.SetVectorIndex(constraint.VectorIndex);
        this.Vector[constraint.VectorIndex] = swapConstraint;
        //  Toggle the state of the constraint being updated.
        this.Vector[this.firstActiveConstraintIndex] = constraint;
        constraint.SetActiveState(!constraint.IsActive, this.firstActiveConstraintIndex);
    }
    Reinitialize() {
        //  Qpsc requires reinitializing the block structure
        if (this.Vector == null) {
            return;
        }
        for (const constraint of this.Vector) {
            constraint.Reinitialize();
        }
        this.firstActiveConstraintIndex = this.Vector.length;
    }
    RecycleDfDvNode(node) {
        //  In the case of long constraint chains make sure this does not end up as big as the number of constraints in the block.
        if (this.DfDvRecycleStack.length < 1024) {
            this.DfDvRecycleStack.push(node);
        }
    }
    toString() {
        return this.Vector.toString();
    }
}
//# sourceMappingURL=ConstraintVector.js.map