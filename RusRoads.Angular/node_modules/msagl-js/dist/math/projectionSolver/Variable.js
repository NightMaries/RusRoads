import { String } from 'typescript-string-operations';
import { compareNumbers } from '../../utils/compare';
// MSAGL class for Variables for Projection Solver.
export class NeighborAndWeight {
    constructor(neighbor, weight) {
        this.Neighbor = neighbor;
        this.Weight = weight;
    }
}
//  A Variable is essentially a wrapper around a node, containing the node's initial and
//  current (Actual) positions along the current axis and a collection of Constraints.
export class Variable {
    constructor(ordinal, userData, desiredPos, weight, scale) {
        this.ActiveConstraintCount = 0;
        if (weight <= 0) {
            throw new Error('weight');
        }
        if (scale <= 0) {
            throw new Error('scale');
        }
        let check = desiredPos * weight;
        if (!Number.isFinite(check) || Number.isNaN(check)) {
            throw new Error('desiredPos');
        }
        check = desiredPos * scale;
        if (!Number.isFinite(check) || Number.isNaN(check)) {
            throw new Error('desiredPos');
        }
        this.Ordinal = ordinal;
        this.UserData = userData;
        this.DesiredPos = desiredPos;
        this.Weight = weight;
        this.Scale = scale;
        this.OffsetInBlock = 0;
        this.ActualPos = this.DesiredPos;
    }
    //  The derivative value - essentially the weighted difference in position.
    get DfDv() {
        return (2 * (this.Weight * (this.ActualPos - this.DesiredPos))) / this.Scale;
    }
    Reinitialize() {
        // // Called by Qpsc or equivalence-constraint-regapping initial block restructuring.
        this.ActiveConstraintCount = 0;
        this.OffsetInBlock = 0.0;
        // If we are in Qpsc, this simply repeats (in the opposite direction) what
        // Qpsc.VariablesComplete did after (possibly) scaling.  If we're not in Qpsc,
        // then we've reset all the blocks because we could not incrementally re-Solve
        // due to changes to equality constraints, so this restores the initial state.
        this.ActualPos = this.DesiredPos;
    }
    AddNeighbor(neighbor, weight) {
        if (this.Neighbors == null) {
            this.Neighbors = new Array();
        }
        this.Neighbors.push(new NeighborAndWeight(neighbor, weight));
    }
    //  Gets a string representation of the Variable; calls UserData.ToString as part of this.
    //  <returns>A string representation of the variable.</returns>
    toString() {
        return String.Format('{0} {1:F5} ({2:F5}) {3:F5} {4:F5}', this.Name, this.ActualPos, this.DesiredPos, this.Weight, this.Scale);
    }
    // Gets the string representation of UserData.
    // <returns>A string representation of Node.Object.</returns>
    get Name() {
        return this.UserData == null ? '-0-' : this.UserData.toString();
    }
    SetConstraints(leftConstraints, rightConstraints) {
        this.LeftConstraints = leftConstraints;
        this.RightConstraints = rightConstraints;
    }
    //  Compare the Variables by their ordinals, in ascending order (this == lhs, other == rhs).
    //  <param name="other">The object being compared to.</param>
    //  <returns>-1 if this.Ordinal is "less"; +1 if this.Ordinal is "greater"; 0 if this.Ordinal
    //          and rhs are equal.</returns>
    CompareTo(other) {
        return compareNumbers(this.Ordinal, other.Ordinal);
    }
}
//# sourceMappingURL=Variable.js.map