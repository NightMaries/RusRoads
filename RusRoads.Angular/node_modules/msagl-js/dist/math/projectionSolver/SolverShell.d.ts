import { Solution } from './Solution';
import { Solver } from './Solver';
import { Variable } from './Variable';
export declare class SolverShell {
    static FixedVarWeight: number;
    variables: Map<number, Variable>;
    solver: Solver;
    solution: Solution;
    fixedVars: Map<number, number>;
    constructor();
    AddVariableWithIdealPositionNNN(id: number, position: number, weight: number): void;
    AddVariableWithIdealPositionNN(id: number, position: number): void;
    AddLeftRightSeparationConstraintNNNB(idLeft: number, idRight: number, gap: number, isEquality: boolean): void;
    AddLeftRightSeparationConstraintNNN(idLeft: number, idRight: number, gap: number): void;
    AddGoalTwoVariablesAreCloseNNN(id1: number, id2: number, weight: number): void;
    AddGoalTwoVariablesAreClose(id1: number, id2: number): void;
    GetVariable(i: number): Variable;
    Solve(): void;
    SolveP(parameters: any): void;
    SolvePNS(parameters: any, t: {
        executionLimitExceeded: boolean;
    }): boolean;
    AdjustConstraintsForMovedFixedVars(): boolean;
    static Close(a: number, b: number): boolean;
    AdjustConstraintsForMovedFixedVarSet(movedFixedVars: Set<number>): boolean;
    AdjustSubtreeOfFixedVar(fixedVar: number, movedFixedVars: Set<number>): boolean;
    AdjustConstraintsOfNeighborsOfFixedVariable(fixedVar: number, t: {
        successInAdjusting: boolean;
    }): Array<number>;
    readonly FailToAdjustEpsilon = 0.001;
    FixActiveConstraints(neighbs: Array<Variable>, scale: number): boolean;
    GetVariableResolvedPosition(id: number): number;
    InitSolver(): void;
    AddFixedVariable(id: number, position: number): void;
    ContainsVariable(v: number): boolean;
    GetVariableIdealPosition(v: number): number;
    get Solution(): Solution;
}
