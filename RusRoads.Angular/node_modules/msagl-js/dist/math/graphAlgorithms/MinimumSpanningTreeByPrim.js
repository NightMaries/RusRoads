import { BinaryHeapPriorityQueue } from '../../structs/BinaryHeapPriorityQueue';
export class MinimumSpanningTreeByPrim {
    constructor(graph, weight, root) {
        this.treeNodes = new Set();
        // map of neighbors of the tree to the edges connected them to the tree
        this.hedgehog = new Map();
        this.graph = graph;
        this.weight = weight;
        this.root = root;
        this.q = new BinaryHeapPriorityQueue(this.graph.nodeCount);
    }
    NodeIsInTree(i) {
        return this.treeNodes.has(i);
    }
    GetTreeEdges() {
        const ret = new Array();
        this.Init();
        while (ret.length < this.graph.nodeCount - 1 && this.q.Count > 0)
            //some nodes might have no edges
            this.AddEdgeToTree(ret);
        return ret;
    }
    AddEdgeToTree(ret) {
        const v = this.q.Dequeue();
        const e = this.hedgehog.get(v);
        this.treeNodes.add(v);
        ret.push(e);
        this.UpdateOutEdgesOfV(v);
        this.UpdateInEdgesOfV(v);
    }
    UpdateOutEdgesOfV(v) {
        for (const outEdge of this.graph.outEdges[v]) {
            const u = outEdge.target;
            if (this.NodeIsInTree(u)) {
                continue;
            }
            const oldEdge = this.hedgehog.get(u);
            if (oldEdge) {
                const oldWeight = this.weight(oldEdge);
                const newWeight = this.weight(outEdge);
                if (newWeight < oldWeight) {
                    this.q.DecreasePriority(u, newWeight);
                    this.hedgehog.set(u, outEdge);
                }
            }
            else {
                this.q.Enqueue(u, this.weight(outEdge));
                this.hedgehog.set(u, outEdge);
            }
        }
    }
    UpdateInEdgesOfV(v) {
        for (const inEdge of this.graph.inEdges[v]) {
            const u = inEdge.source;
            if (this.NodeIsInTree(u)) {
                continue;
            }
            const oldEdge = this.hedgehog.get(u);
            if (oldEdge) {
                const oldWeight = this.weight(oldEdge);
                const newWeight = this.weight(inEdge);
                if (newWeight < oldWeight) {
                    this.q.DecreasePriority(u, newWeight);
                    this.hedgehog.set(u, inEdge);
                }
            }
            else {
                this.q.Enqueue(u, this.weight(inEdge));
                this.hedgehog.set(u, inEdge);
            }
        }
    }
    Init() {
        this.treeNodes.add(this.root);
        for (const outEdge of this.graph.outEdges[this.root]) {
            const w = this.weight(outEdge);
            this.q.Enqueue(outEdge.target, w);
            this.hedgehog.set(outEdge.target, outEdge);
        }
        for (const inEdge of this.graph.inEdges[this.root]) {
            const w = this.weight(inEdge);
            this.q.Enqueue(inEdge.source, w);
            this.hedgehog.set(inEdge.source, inEdge);
        }
    }
}
//# sourceMappingURL=MinimumSpanningTreeByPrim.js.map