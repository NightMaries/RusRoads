import { Entity } from './entity';
export class Node extends Entity {
    constructor(id) {
        super();
        this.inEdges = new Set();
        this.outEdges = new Set();
        this.selfEdges = new Set();
        //  Assert.assert(id != null && id.toString() === id)
        this.id = id;
    }
    get id() {
        return this._id;
    }
    set id(value) {
        /*Assert.assert(value != null)*/
        this._id = value;
    }
    toString() {
        return this.id;
    }
    get isGraph() {
        return false;
    }
    *graphs() {
        if (this.isGraph) {
            const nc = this.nodeCollection;
            for (const g of nc.graphs) {
                yield g;
            }
        }
    }
    *_edges() {
        for (const e of this.inEdges)
            yield e;
        for (const e of this.outEdges)
            yield e;
        for (const e of this.selfEdges)
            yield e;
    }
    addInEdge(edge) {
        /*Assert.assert(edge.target == this)*/
        this.inEdges.add(edge);
    }
    addOutEdge(edge) {
        /*Assert.assert(edge.source == this)*/
        this.outEdges.add(edge);
    }
    addSelfEdge(edge) {
        /*Assert.assert(edge.source == edge.target && edge.source == this)*/
        this.selfEdges.add(edge);
    }
    addEdde(e) {
        if (this == e.source) {
            if (e.target == this)
                this.addSelfEdge(e);
            else
                this.addOutEdge(e);
        }
        else if (this == e.target) {
            this.addInEdge(e);
        }
        else {
            throw new Error('attaching an edge to non adjacent node');
            // Assert.assert(false, 'attaching an edge to non adjacent node')
        }
        return e;
    }
    get edges() {
        return this._edges();
    }
    get outDegree() {
        return this.outEdges.size;
    }
    get inDegree() {
        return this.inEdges.size;
    }
    get selfDegree() {
        return this.selfEdges.size;
    }
    get degree() {
        return this.outDegree + this.inDegree + this.selfDegree;
    }
    *getAncestors() {
        let g = this.parent;
        while (g != null) {
            yield g;
            g = g.parent;
        }
    }
    isUnderCollapsedGraph() {
        return this.parent != null && this.parent.isCollapsed;
    }
}
//# sourceMappingURL=node.js.map