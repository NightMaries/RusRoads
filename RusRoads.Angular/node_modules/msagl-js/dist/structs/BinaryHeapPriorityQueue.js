//  A priority queue based on the binary heap algorithm
export class BinaryHeapPriorityQueue {
    //  the constructor
    //  we assume that all integers inserted into the queue will be non-negative and less then n
    constructor(n) {
        this.heapSize = 0;
        this._priors = new Array(n);
        this._heap = new Array(n + 1);
        // because indexing for A starts from 1
        this._reverse_heap = new Array(n);
    }
    get Count() {
        return this.heapSize;
    }
    SwapWithParent(i) {
        const parent = this._heap[i >> 1];
        this.PutAtI(i >> 1, this._heap[i]);
        this.PutAtI(i, parent);
    }
    Enqueue(o, priority) {
        this.heapSize++;
        let i = this.heapSize;
        this._priors[o] = priority;
        this.PutAtI(i, o);
        while (i > 1 && this._priors[this._heap[i >> 1]] > priority) {
            this.SwapWithParent(i);
            i >>= 1;
        }
    }
    PutAtI(i, h) {
        this._heap[i] = h;
        this._reverse_heap[h] = i;
    }
    //  return the first element of the queue and removes it from the queue
    Dequeue() {
        if (this.heapSize == 0) {
            throw new Error();
        }
        const ret = this._heap[1];
        if (this.heapSize > 1) {
            this.PutAtI(1, this._heap[this.heapSize]);
            let i = 1;
            while (true) {
                let smallest = i;
                const l = i << 1;
                if (l <= this.heapSize && this._priors[this._heap[l]] < this._priors[this._heap[i]]) {
                    smallest = l;
                }
                const r = l + 1;
                if (r <= this.heapSize && this._priors[this._heap[r]] < this._priors[this._heap[smallest]]) {
                    smallest = r;
                }
                if (smallest != i) {
                    this.SwapWithParent(smallest);
                }
                else {
                    break;
                }
                i = smallest;
            }
        }
        this.heapSize--;
        return ret;
    }
    IsEmpty() {
        return this.heapSize == 0;
    }
    DecreasePriority(o, newPriority) {
        // System.Diagnostics.Debug.WriteLine("delcrease "+ o.ToString()+" to "+ newPriority.ToString());
        this._priors[o] = newPriority;
        let i = this._reverse_heap[o];
        while (i > 1) {
            if (this._priors[this._heap[i]] < this._priors[this._heap[i >> 1]]) {
                this.SwapWithParent(i);
            }
            else {
                break;
            }
            i >>= 1;
        }
    }
}
//# sourceMappingURL=BinaryHeapPriorityQueue.js.map