//  Generic version priority queue based on the binary heap algorithm where
import { StringBuilder } from 'typescript-string-operations';
import { compareNumbers } from '../utils/compare';
import { GenericHeapElement } from './genericHeapElement';
//  the priority of each element is passed as a parameter.
export class GenericBinaryHeapPriorityQueue {
    constructor(compare = compareNumbers) {
        this.heapSize = 0;
        this.compare = compare;
        this.cache = new Map();
        this.A = [];
    }
    get count() {
        return this.heapSize;
    }
    ContainsElement(key) {
        return this.cache.has(key);
    }
    SwapWithParent(i) {
        const parent = this.A[i >> 1];
        this.PutAtI(i >> 1, this.A[i]);
        this.PutAtI(i, parent);
    }
    Enqueue(element, priority) {
        let i = ++this.heapSize;
        const h = new GenericHeapElement(i, priority, element);
        this.cache.set(element, h);
        this.A[i] = h;
        while (i > 1 && this.compare(this.A[i >> 1].priority, priority) > 0) {
            this.SwapWithParent(i);
            i >>= 1;
        }
    }
    IsEmpty() {
        return this.heapSize == 0;
    }
    PutAtI(i, h) {
        this.A[i] = h;
        h.indexToA = i;
    }
    Dequeue() {
        if (this.heapSize == 0) {
            throw new Error('dequeue on an empty queue');
        }
        const ret = this.A[1].v;
        this.MoveQueueOneStepForward(ret);
        return ret;
    }
    DequeueAndGetPriority(t) {
        if (this.heapSize == 0) {
            throw new Error('dequeue on an empty queue');
        }
        const ret = this.A[1].v;
        t.priority = this.A[1].priority;
        this.MoveQueueOneStepForward(ret);
        return ret;
    }
    MoveQueueOneStepForward(ret) {
        this.cache.delete(ret);
        this.PutAtI(1, this.A[this.heapSize]);
        let i = 1;
        while (true) {
            let smallest = i;
            const l = i << 1;
            if (l <= this.heapSize && this.compare(this.A[l].priority, this.A[i].priority) < 0) {
                smallest = l;
            }
            const r = l + 1;
            if (r <= this.heapSize && this.compare(this.A[r].priority, this.A[smallest].priority) < 0) {
                smallest = r;
            }
            if (smallest != i) {
                this.SwapWithParent(smallest);
            }
            else {
                break;
            }
            i = smallest;
        }
        this.heapSize--;
    }
    DecreasePriority(element, newPriority) {
        const h = this.cache.get(element);
        // ignore the element if it is not in the queue
        if (!h) {
            return;
        }
        // var h = cache[element];
        h.priority = newPriority;
        let i = h.indexToA;
        while (i > 1) {
            if (this.compare(this.A[i].priority, this.A[i >> 1].priority) < 0) {
                this.SwapWithParent(i);
            }
            else {
                break;
            }
            i >>= 1;
        }
    }
    *GetEnumerator() {
        for (let i = 1; i <= this.heapSize; i++) {
            yield this.A[i].v;
        }
    }
    //
    Peek(t) {
        if (this.count == 0) {
            t.priority = 0;
            return;
        }
        t.priority = this.A[1].priority;
        return this.A[1].v;
    }
    toString() {
        const sb = new StringBuilder();
        for (const i of this.A) {
            sb.Append(i + ',');
        }
        return sb.ToString();
    }
}
//# sourceMappingURL=genericBinaryHeapPriorityQueue.js.map